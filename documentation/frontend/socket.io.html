<!DOCTYPE html>

<html>
<head>
  <title>socket.io.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="app.html">
                app.js
              </a>
            
              
              <a class="source" href="cam.html">
                cam.js
              </a>
            
              
              <a class="source" href="dashboard.html">
                dashboard.js
              </a>
            
              
              <a class="source" href="login.html">
                login.js
              </a>
            
              
              <a class="source" href="main.html">
                main.js
              </a>
            
              
              <a class="source" href="sflowmap.html">
                sflowmap.js
              </a>
            
              
              <a class="source" href="sheatmap.html">
                sheatmap.js
              </a>
            
              
              <a class="source" href="heatFilter.html">
                heatFilter.js
              </a>
            
              
              <a class="source" href="sails.io.html">
                sails.io.js
              </a>
            
              
              <a class="source" href="socket.io.html">
                socket.io.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>socket.io.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-comment">/*! Socket.IO.js build:0.9.16, development. Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt; MIT Licensed */</span>

<span class="hljs-keyword">var</span> io = (<span class="hljs-string">'undefined'</span> === <span class="hljs-keyword">typeof</span> module ? {} : module.exports);
(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, global)</span> {</span>

  <span class="hljs-comment">/**
   * IO namespace.
   *
   * @namespace
   */</span>

  <span class="hljs-keyword">var</span> io = exports;

  <span class="hljs-comment">/**
   * Socket.IO version
   *
   * @api public
   */</span>

  io.version = <span class="hljs-string">'0.9.16'</span>;

  <span class="hljs-comment">/**
   * Protocol implemented.
   *
   * @api public
   */</span>

  io.protocol = <span class="hljs-number">1</span>;

  <span class="hljs-comment">/**
   * Available transports, these will be populated with the available transports
   *
   * @api public
   */</span>

  io.transports = [];

  <span class="hljs-comment">/**
   * Keep track of jsonp callbacks.
   *
   * @api private
   */</span>

  io.j = [];

  <span class="hljs-comment">/**
   * Keep track of our io.Sockets
   *
   * @api private
   */</span>
  io.sockets = {};


  <span class="hljs-comment">/**
   * Manages connections to hosts.
   *
   * @param {String} uri
   * @Param {Boolean} force creation of new socket (defaults to false)
   * @api public
   */</span>

  io.connect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(host, details)</span> {</span>
    <span class="hljs-keyword">var</span> uri = io.util.parseUri(host)
      , uuri
      , socket;

    <span class="hljs-keyword">if</span> (global &amp;&amp; global.location) {
      uri.protocol = uri.protocol || global.location.protocol.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
      uri.host = uri.host || (global.document
        ? global.document.domain : global.location.hostname);
      uri.port = uri.port || global.location.port;
    }

    uuri = io.util.uniqueUri(uri);

    <span class="hljs-keyword">var</span> options = {
        host: uri.host
      , secure: <span class="hljs-string">'https'</span> == uri.protocol
      , port: uri.port || (<span class="hljs-string">'https'</span> == uri.protocol ? <span class="hljs-number">443</span> : <span class="hljs-number">80</span>)
      , query: uri.query || <span class="hljs-string">''</span>
    };

    io.util.merge(options, details);

    <span class="hljs-keyword">if</span> (options[<span class="hljs-string">'force new connection'</span>] || !io.sockets[uuri]) {
      socket = <span class="hljs-keyword">new</span> io.Socket(options);
    }

    <span class="hljs-keyword">if</span> (!options[<span class="hljs-string">'force new connection'</span>] &amp;&amp; socket) {
      io.sockets[uuri] = socket;
    }

    socket = socket || io.sockets[uuri];</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>if path is different from ‘’ or /</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> socket.of(uri.path.length &gt; <span class="hljs-number">1</span> ? uri.path : <span class="hljs-string">''</span>);
  };

})(<span class="hljs-string">'object'</span> === <span class="hljs-keyword">typeof</span> module ? module.exports : (<span class="hljs-keyword">this</span>.io = {}), <span class="hljs-keyword">this</span>);
<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, global)</span> {</span>

  <span class="hljs-comment">/**
   * Utilities namespace.
   *
   * @namespace
   */</span>

  <span class="hljs-keyword">var</span> util = exports.util = {};

  <span class="hljs-comment">/**
   * Parses an URI
   *
   * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
   * @api public
   */</span>

  <span class="hljs-keyword">var</span> re = <span class="hljs-regexp">/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/</span>;

  <span class="hljs-keyword">var</span> parts = [<span class="hljs-string">'source'</span>, <span class="hljs-string">'protocol'</span>, <span class="hljs-string">'authority'</span>, <span class="hljs-string">'userInfo'</span>, <span class="hljs-string">'user'</span>, <span class="hljs-string">'password'</span>,
               <span class="hljs-string">'host'</span>, <span class="hljs-string">'port'</span>, <span class="hljs-string">'relative'</span>, <span class="hljs-string">'path'</span>, <span class="hljs-string">'directory'</span>, <span class="hljs-string">'file'</span>, <span class="hljs-string">'query'</span>,
               <span class="hljs-string">'anchor'</span>];

  util.parseUri = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(str)</span> {</span>
    <span class="hljs-keyword">var</span> m = re.exec(str || <span class="hljs-string">''</span>)
      , uri = {}
      , i = <span class="hljs-number">14</span>;

    <span class="hljs-keyword">while</span> (i--) {
      uri[parts[i]] = m[i] || <span class="hljs-string">''</span>;
    }

    <span class="hljs-keyword">return</span> uri;
  };

  <span class="hljs-comment">/**
   * Produces a unique url that identifies a Socket.IO connection.
   *
   * @param {Object} uri
   * @api public
   */</span>

  util.uniqueUri = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(uri)</span> {</span>
    <span class="hljs-keyword">var</span> protocol = uri.protocol
      , host = uri.host
      , port = uri.port;

    <span class="hljs-keyword">if</span> (<span class="hljs-string">'document'</span> <span class="hljs-keyword">in</span> global) {
      host = host || document.domain;
      port = port || (protocol == <span class="hljs-string">'https'</span>
        &amp;&amp; document.location.protocol !== <span class="hljs-string">'https:'</span> ? <span class="hljs-number">443</span> : document.location.port);
    } <span class="hljs-keyword">else</span> {
      host = host || <span class="hljs-string">'localhost'</span>;

      <span class="hljs-keyword">if</span> (!port &amp;&amp; protocol == <span class="hljs-string">'https'</span>) {
        port = <span class="hljs-number">443</span>;
      }
    }

    <span class="hljs-keyword">return</span> (protocol || <span class="hljs-string">'http'</span>) + <span class="hljs-string">'://'</span> + host + <span class="hljs-string">':'</span> + (port || <span class="hljs-number">80</span>);
  };

  <span class="hljs-comment">/**
   * Mergest 2 query strings in to once unique query string
   *
   * @param {String} base
   * @param {String} addition
   * @api public
   */</span>

  util.query = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(base, addition)</span> {</span>
    <span class="hljs-keyword">var</span> query = util.chunkQuery(base || <span class="hljs-string">''</span>)
      , components = [];

    util.merge(query, util.chunkQuery(addition || <span class="hljs-string">''</span>));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> part <span class="hljs-keyword">in</span> query) {
      <span class="hljs-keyword">if</span> (query.hasOwnProperty(part)) {
        components.push(part + <span class="hljs-string">'='</span> + query[part]);
      }
    }

    <span class="hljs-keyword">return</span> components.length ? <span class="hljs-string">'?'</span> + components.join(<span class="hljs-string">'&amp;'</span>) : <span class="hljs-string">''</span>;
  };

  <span class="hljs-comment">/**
   * Transforms a querystring in to an object
   *
   * @param {String} qs
   * @api public
   */</span>

  util.chunkQuery = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(qs)</span> {</span>
    <span class="hljs-keyword">var</span> query = {}
      , params = qs.split(<span class="hljs-string">'&amp;'</span>)
      , i = <span class="hljs-number">0</span>
      , l = params.length
      , kv;

    <span class="hljs-keyword">for</span> (; i &lt; l; ++i) {
      kv = params[i].split(<span class="hljs-string">'='</span>);
      <span class="hljs-keyword">if</span> (kv[<span class="hljs-number">0</span>]) {
        query[kv[<span class="hljs-number">0</span>]] = kv[<span class="hljs-number">1</span>];
      }
    }

    <span class="hljs-keyword">return</span> query;
  };

  <span class="hljs-comment">/**
   * Executes the given function when the page is loaded.
   *
   *     io.util.load(function () { console.log('page loaded'); });
   *
   * @param {Function} fn
   * @api public
   */</span>

  <span class="hljs-keyword">var</span> pageLoaded = <span class="hljs-literal">false</span>;

  util.load = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">'document'</span> <span class="hljs-keyword">in</span> global &amp;&amp; document.readyState === <span class="hljs-string">'complete'</span> || pageLoaded) {
      <span class="hljs-keyword">return</span> fn();
    }

    util.on(global, <span class="hljs-string">'load'</span>, fn, <span class="hljs-literal">false</span>);
  };

  <span class="hljs-comment">/**
   * Adds an event.
   *
   * @api private
   */</span>

  util.on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(element, event, fn, capture)</span> {</span>
    <span class="hljs-keyword">if</span> (element.attachEvent) {
      element.attachEvent(<span class="hljs-string">'on'</span> + event, fn);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.addEventListener) {
      element.addEventListener(event, fn, capture);
    }
  };

  <span class="hljs-comment">/**
   * Generates the correct `XMLHttpRequest` for regular and cross domain requests.
   *
   * @param {Boolean} [xdomain] Create a request that can be used cross domain.
   * @returns {XMLHttpRequest|false} If we can create a XMLHttpRequest.
   * @api private
   */</span>

  util.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(xdomain)</span> {</span>

    <span class="hljs-keyword">if</span> (xdomain &amp;&amp; <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> XDomainRequest &amp;&amp; !util.ua.hasCORS) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XDomainRequest();
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> XMLHttpRequest &amp;&amp; (!xdomain || util.ua.hasCORS)) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XMLHttpRequest();
    }

    <span class="hljs-keyword">if</span> (!xdomain) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> window[([<span class="hljs-string">'Active'</span>].concat(<span class="hljs-string">'Object'</span>).join(<span class="hljs-string">'X'</span>))](<span class="hljs-string">'Microsoft.XMLHTTP'</span>);
      } <span class="hljs-keyword">catch</span>(e) { }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  };

  <span class="hljs-comment">/**
   * XHR based transport constructor.
   *
   * @constructor
   * @api public
   */</span>

  <span class="hljs-comment">/**
   * Change the internal pageLoaded value.
   */</span>

  <span class="hljs-keyword">if</span> (<span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> window) {
    util.load(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      pageLoaded = <span class="hljs-literal">true</span>;
    });
  }

  <span class="hljs-comment">/**
   * Defers a function to ensure a spinner is not displayed by the browser
   *
   * @param {Function} fn
   * @api public
   */</span>

  util.defer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">if</span> (!util.ua.webkit || <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> importScripts) {
      <span class="hljs-keyword">return</span> fn();
    }

    util.load(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      setTimeout(fn, <span class="hljs-number">100</span>);
    });
  };

  <span class="hljs-comment">/**
   * Merges two objects.
   *
   * @api public
   */</span>

  util.merge = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span> <span class="hljs-params">(target, additional, deep, lastseen)</span> {</span>
    <span class="hljs-keyword">var</span> seen = lastseen || []
      , depth = <span class="hljs-keyword">typeof</span> deep == <span class="hljs-string">'undefined'</span> ? <span class="hljs-number">2</span> : deep
      , prop;

    <span class="hljs-keyword">for</span> (prop <span class="hljs-keyword">in</span> additional) {
      <span class="hljs-keyword">if</span> (additional.hasOwnProperty(prop) &amp;&amp; util.indexOf(seen, prop) &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target[prop] !== <span class="hljs-string">'object'</span> || !depth) {
          target[prop] = additional[prop];
          seen.push(additional[prop]);
        } <span class="hljs-keyword">else</span> {
          util.merge(target[prop], additional[prop], depth - <span class="hljs-number">1</span>, seen);
        }
      }
    }

    <span class="hljs-keyword">return</span> target;
  };

  <span class="hljs-comment">/**
   * Merges prototypes from objects
   *
   * @api public
   */</span>

  util.mixin = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ctor, ctor2)</span> {</span>
    util.merge(ctor.prototype, ctor2.prototype);
  };

  <span class="hljs-comment">/**
   * Shortcut for prototypical and static inheritance.
   *
   * @api private
   */</span>

  util.inherit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ctor, ctor2)</span> {</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> {</span>};
    f.prototype = ctor2.prototype;
    ctor.prototype = <span class="hljs-keyword">new</span> f;
  };

  <span class="hljs-comment">/**
   * Checks if the given object is an Array.
   *
   *     io.util.isArray([]); // true
   *     io.util.isArray({}); // false
   *
   * @param Object obj
   * @api public
   */</span>

  util.isArray = <span class="hljs-built_in">Array</span>.isArray || <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(obj)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj) === <span class="hljs-string">'[object Array]'</span>;
  };

  <span class="hljs-comment">/**
   * Intersects values of two arrays into a third
   *
   * @api public
   */</span>

  util.intersect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr, arr2)</span> {</span>
    <span class="hljs-keyword">var</span> ret = []
      , longest = arr.length &gt; arr2.length ? arr : arr2
      , shortest = arr.length &gt; arr2.length ? arr2 : arr;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = shortest.length; i &lt; l; i++) {
      <span class="hljs-keyword">if</span> (~util.indexOf(longest, shortest[i]))
        ret.push(shortest[i]);
    }

    <span class="hljs-keyword">return</span> ret;
  };

  <span class="hljs-comment">/**
   * Array indexOf compatibility.
   *
   * @see bit.ly/a5Dxa2
   * @api public
   */</span>

  util.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr, o, i)</span> {</span>

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = arr.length, i = i &lt; <span class="hljs-number">0</span> ? i + j &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : i + j : i || <span class="hljs-number">0</span>;
         i &lt; j &amp;&amp; arr[i] !== o; i++) {}

    <span class="hljs-keyword">return</span> j &lt;= i ? -<span class="hljs-number">1</span> : i;
  };

  <span class="hljs-comment">/**
   * Converts enumerables to array.
   *
   * @api public
   */</span>

  util.toArray = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(enu)</span> {</span>
    <span class="hljs-keyword">var</span> arr = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = enu.length; i &lt; l; i++)
      arr.push(enu[i]);

    <span class="hljs-keyword">return</span> arr;
  };

  <span class="hljs-comment">/**
   * UA / engines detection namespace.
   *
   * @namespace
   */</span>

  util.ua = {};

  <span class="hljs-comment">/**
   * Whether the UA supports CORS for XHR.
   *
   * @api public
   */</span>

  util.ua.hasCORS = <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> XMLHttpRequest &amp;&amp; (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> XMLHttpRequest();
    } <span class="hljs-keyword">catch</span> (e) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> a.withCredentials != <span class="hljs-literal">undefined</span>;
  })();

  <span class="hljs-comment">/**
   * Detect webkit.
   *
   * @api public
   */</span>

  util.ua.webkit = <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> navigator
    &amp;&amp; <span class="hljs-regexp">/webkit/i</span>.test(navigator.userAgent);

   <span class="hljs-comment">/**
   * Detect iPad/iPhone/iPod.
   *
   * @api public
   */</span>

  util.ua.iDevice = <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> navigator
      &amp;&amp; <span class="hljs-regexp">/iPad|iPhone|iPod/i</span>.test(navigator.userAgent);

})(<span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.exports, <span class="hljs-keyword">this</span>);
<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io)</span> {</span>

  <span class="hljs-comment">/**
   * Expose constructor.
   */</span>

  exports.EventEmitter = EventEmitter;

  <span class="hljs-comment">/**
   * Event emitter constructor.
   *
   * @api public.
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EventEmitter</span> <span class="hljs-params">()</span> {</span>};

  <span class="hljs-comment">/**
   * Adds a listener
   *
   * @api public
   */</span>

  EventEmitter.prototype.on = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, fn)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.$events) {
      <span class="hljs-keyword">this</span>.$events = {};
    }

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.$events[name]) {
      <span class="hljs-keyword">this</span>.$events[name] = fn;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (io.util.isArray(<span class="hljs-keyword">this</span>.$events[name])) {
      <span class="hljs-keyword">this</span>.$events[name].push(fn);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.$events[name] = [<span class="hljs-keyword">this</span>.$events[name], fn];
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  <span class="hljs-comment">/**
   * Adds a volatile listener.
   *
   * @api public
   */</span>

  EventEmitter.prototype.once = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, fn)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">on</span> <span class="hljs-params">()</span> {</span>
      self.removeListener(name, on);
      fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    };

    on.listener = fn;
    <span class="hljs-keyword">this</span>.on(name, on);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Removes a listener.
   *
   * @api public
   */</span>

  EventEmitter.prototype.removeListener = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, fn)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$events &amp;&amp; <span class="hljs-keyword">this</span>.$events[name]) {
      <span class="hljs-keyword">var</span> list = <span class="hljs-keyword">this</span>.$events[name];

      <span class="hljs-keyword">if</span> (io.util.isArray(list)) {
        <span class="hljs-keyword">var</span> pos = -<span class="hljs-number">1</span>;

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = list.length; i &lt; l; i++) {
          <span class="hljs-keyword">if</span> (list[i] === fn || (list[i].listener &amp;&amp; list[i].listener === fn)) {
            pos = i;
            <span class="hljs-keyword">break</span>;
          }
        }

        <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span>) {
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
        }

        list.splice(pos, <span class="hljs-number">1</span>);

        <span class="hljs-keyword">if</span> (!list.length) {
          <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.$events[name];
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (list === fn || (list.listener &amp;&amp; list.listener === fn)) {
        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.$events[name];
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Removes all listeners for an event.
   *
   * @api public
   */</span>

  EventEmitter.prototype.removeAllListeners = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
    <span class="hljs-keyword">if</span> (name === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">this</span>.$events = {};
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$events &amp;&amp; <span class="hljs-keyword">this</span>.$events[name]) {
      <span class="hljs-keyword">this</span>.$events[name] = <span class="hljs-literal">null</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Gets all listeners for a certain event.
   *
   * @api publci
   */</span>

  EventEmitter.prototype.listeners = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.$events) {
      <span class="hljs-keyword">this</span>.$events = {};
    }

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.$events[name]) {
      <span class="hljs-keyword">this</span>.$events[name] = [];
    }

    <span class="hljs-keyword">if</span> (!io.util.isArray(<span class="hljs-keyword">this</span>.$events[name])) {
      <span class="hljs-keyword">this</span>.$events[name] = [<span class="hljs-keyword">this</span>.$events[name]];
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$events[name];
  };

  <span class="hljs-comment">/**
   * Emits an event.
   *
   * @api public
   */</span>

  EventEmitter.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.$events) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">this</span>.$events[name];

    <span class="hljs-keyword">if</span> (!handler) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-string">'function'</span> == <span class="hljs-keyword">typeof</span> handler) {
      handler.apply(<span class="hljs-keyword">this</span>, args);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (io.util.isArray(handler)) {
      <span class="hljs-keyword">var</span> listeners = handler.slice();

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = listeners.length; i &lt; l; i++) {
        listeners[i].apply(<span class="hljs-keyword">this</span>, args);
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
);

<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

<span class="hljs-comment">/**
 * Based on JSON2 (http://www.JSON.org/js.html).
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, nativeJSON)</span> {</span>
<span class="hljs-pi">  "use strict"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>use native JSON if it’s available</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (nativeJSON &amp;&amp; nativeJSON.parse){
    <span class="hljs-keyword">return</span> exports.JSON = {
      parse: nativeJSON.parse
    , stringify: nativeJSON.stringify
    };
  }

  <span class="hljs-keyword">var</span> <span class="hljs-built_in">JSON</span> = exports.JSON = {};

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span><span class="hljs-params">(n)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Format integers to have at least two digits.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">10</span> ? <span class="hljs-string">'0'</span> + n : n;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">date</span><span class="hljs-params">(d, key)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">isFinite</span>(d.valueOf()) ?
        d.getUTCFullYear()     + <span class="hljs-string">'-'</span> +
        f(d.getUTCMonth() + <span class="hljs-number">1</span>) + <span class="hljs-string">'-'</span> +
        f(d.getUTCDate())      + <span class="hljs-string">'T'</span> +
        f(d.getUTCHours())     + <span class="hljs-string">':'</span> +
        f(d.getUTCMinutes())   + <span class="hljs-string">':'</span> +
        f(d.getUTCSeconds())   + <span class="hljs-string">'Z'</span> : <span class="hljs-literal">null</span>;
  };

  <span class="hljs-keyword">var</span> cx = <span class="hljs-regexp">/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g</span>,
      escapable = <span class="hljs-regexp">/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g</span>,
      gap,
      indent,
      meta = {    <span class="hljs-comment">// table of character substitutions</span>
          <span class="hljs-string">'\b'</span>: <span class="hljs-string">'\\b'</span>,
          <span class="hljs-string">'\t'</span>: <span class="hljs-string">'\\t'</span>,
          <span class="hljs-string">'\n'</span>: <span class="hljs-string">'\\n'</span>,
          <span class="hljs-string">'\f'</span>: <span class="hljs-string">'\\f'</span>,
          <span class="hljs-string">'\r'</span>: <span class="hljs-string">'\\r'</span>,
          <span class="hljs-string">'"'</span> : <span class="hljs-string">'\\"'</span>,
          <span class="hljs-string">'\\'</span>: <span class="hljs-string">'\\\\'</span>
      },
      rep;


  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quote</span><span class="hljs-params">(string)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>If the string contains no control characters, no quote characters, and no
backslash characters, then we can safely slap some quotes around it.
Otherwise we must also replace the offending characters with safe escape
sequences.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      escapable.lastIndex = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> escapable.test(string) ? <span class="hljs-string">'"'</span> + string.replace(escapable, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a)</span> {</span>
          <span class="hljs-keyword">var</span> c = meta[a];
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> c === <span class="hljs-string">'string'</span> ? c :
              <span class="hljs-string">'\\u'</span> + (<span class="hljs-string">'0000'</span> + a.charCodeAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>)).slice(-<span class="hljs-number">4</span>);
      }) + <span class="hljs-string">'"'</span> : <span class="hljs-string">'"'</span> + string + <span class="hljs-string">'"'</span>;
  }


  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">str</span><span class="hljs-params">(key, holder)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Produce a string from holder[key].</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> i,          <span class="hljs-comment">// The loop counter.</span>
          k,          <span class="hljs-comment">// The member key.</span>
          v,          <span class="hljs-comment">// The member value.</span>
          length,
          mind = gap,
          partial,
          value = holder[key];</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>If the value has a toJSON method, call it to obtain a replacement value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>) {
          value = date(key);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>If we were called with a replacer function, then call the replacer to
obtain a replacement value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> rep === <span class="hljs-string">'function'</span>) {
          value = rep.call(holder, key, value);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>What happens next depends on the value’s type.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">typeof</span> value) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'string'</span>:
          <span class="hljs-keyword">return</span> quote(value);

      <span class="hljs-keyword">case</span> <span class="hljs-string">'number'</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>JSON numbers must be finite. Encode non-finite numbers as null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">isFinite</span>(value) ? <span class="hljs-built_in">String</span>(value) : <span class="hljs-string">'null'</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'boolean'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'null'</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>If the value is a boolean or null, convert it to a string. Note:
typeof null does not produce ‘null’. The case is included here in
the remote chance that this gets fixed someday.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>(value);</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>If the type is ‘object’, we might be dealing with an object or an array or
null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">case</span> <span class="hljs-string">'object'</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>Due to a specification blunder in ECMAScript, typeof null is ‘object’,
so watch out for that case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">if</span> (!value) {
              <span class="hljs-keyword">return</span> <span class="hljs-string">'null'</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Make an array to hold the partial results of stringifying this object value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          gap += indent;
          partial = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Is the value an array?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.apply(value) === <span class="hljs-string">'[object Array]'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>The value is an array. Stringify every element. Use null as a placeholder
for non-JSON values.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              length = value.length;
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i += <span class="hljs-number">1</span>) {
                  partial[i] = str(i, value) || <span class="hljs-string">'null'</span>;
              }</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Join all of the elements together, separated with commas, and wrap them in
brackets.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              v = partial.length === <span class="hljs-number">0</span> ? <span class="hljs-string">'[]'</span> : gap ?
                  <span class="hljs-string">'[\n'</span> + gap + partial.join(<span class="hljs-string">',\n'</span> + gap) + <span class="hljs-string">'\n'</span> + mind + <span class="hljs-string">']'</span> :
                  <span class="hljs-string">'['</span> + partial.join(<span class="hljs-string">','</span>) + <span class="hljs-string">']'</span>;
              gap = mind;
              <span class="hljs-keyword">return</span> v;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>If the replacer is an array, use it to select the members to be stringified.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">if</span> (rep &amp;&amp; <span class="hljs-keyword">typeof</span> rep === <span class="hljs-string">'object'</span>) {
              length = rep.length;
              <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i += <span class="hljs-number">1</span>) {
                  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> rep[i] === <span class="hljs-string">'string'</span>) {
                      k = rep[i];
                      v = str(k, value);
                      <span class="hljs-keyword">if</span> (v) {
                          partial.push(quote(k) + (gap ? <span class="hljs-string">': '</span> : <span class="hljs-string">':'</span>) + v);
                      }
                  }
              }
          } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Otherwise, iterate through all of the keys in the object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
              <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> value) {
                  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(value, k)) {
                      v = str(k, value);
                      <span class="hljs-keyword">if</span> (v) {
                          partial.push(quote(k) + (gap ? <span class="hljs-string">': '</span> : <span class="hljs-string">':'</span>) + v);
                      }
                  }
              }
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Join all of the member texts together, separated with commas,
and wrap them in braces.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          v = partial.length === <span class="hljs-number">0</span> ? <span class="hljs-string">'{}'</span> : gap ?
              <span class="hljs-string">'{\n'</span> + gap + partial.join(<span class="hljs-string">',\n'</span> + gap) + <span class="hljs-string">'\n'</span> + mind + <span class="hljs-string">'}'</span> :
              <span class="hljs-string">'{'</span> + partial.join(<span class="hljs-string">','</span>) + <span class="hljs-string">'}'</span>;
          gap = mind;
          <span class="hljs-keyword">return</span> v;
      }
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>If the JSON object does not yet have a stringify method, give it one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-built_in">JSON</span>.stringify = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value, replacer, space)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The stringify method takes a value and an optional replacer, and an optional
space parameter, and returns a JSON text. The replacer can be a function
that can replace values, or an array of strings that will select the keys.
A default replacer method can be provided. Use of the space parameter can
produce text that is more easily readable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> i;
      gap = <span class="hljs-string">''</span>;
      indent = <span class="hljs-string">''</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>If the space parameter is a number, make an indent string containing that
many spaces.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> space === <span class="hljs-string">'number'</span>) {
          <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; space; i += <span class="hljs-number">1</span>) {
              indent += <span class="hljs-string">' '</span>;
          }</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>If the space parameter is a string, it will be used as the indent string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> space === <span class="hljs-string">'string'</span>) {
          indent = space;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>If there is a replacer, it must be a function or an array.
Otherwise, throw an error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      rep = replacer;
      <span class="hljs-keyword">if</span> (replacer &amp;&amp; <span class="hljs-keyword">typeof</span> replacer !== <span class="hljs-string">'function'</span> &amp;&amp;
              (<span class="hljs-keyword">typeof</span> replacer !== <span class="hljs-string">'object'</span> ||
              <span class="hljs-keyword">typeof</span> replacer.length !== <span class="hljs-string">'number'</span>)) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'JSON.stringify'</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Make a fake root object containing our value under the key of ‘’.
Return the result of stringifying the value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">return</span> str(<span class="hljs-string">''</span>, {<span class="hljs-string">''</span>: value});
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>If the JSON object does not yet have a parse method, give it one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
  <span class="hljs-built_in">JSON</span>.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(text, reviver)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>The parse method takes a text and an optional reviver function, and returns
a JavaScript value if the text is a valid JSON text.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">var</span> j;

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span><span class="hljs-params">(holder, key)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>The walk method is used to recursively walk the resulting structure so
that modifications can be made.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">var</span> k, v, value = holder[key];
          <span class="hljs-keyword">if</span> (value &amp;&amp; <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">'object'</span>) {
              <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> value) {
                  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(value, k)) {
                      v = walk(value, k);
                      <span class="hljs-keyword">if</span> (v !== <span class="hljs-literal">undefined</span>) {
                          value[k] = v;
                      } <span class="hljs-keyword">else</span> {
                          <span class="hljs-keyword">delete</span> value[k];
                      }
                  }
              }
          }
          <span class="hljs-keyword">return</span> reviver.call(holder, key, value);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Parsing happens in four stages. In the first stage, we replace certain
Unicode characters with escape sequences. JavaScript handles many characters
incorrectly, either silently deleting them, or treating them as line endings.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      text = <span class="hljs-built_in">String</span>(text);
      cx.lastIndex = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span> (cx.test(text)) {
          text = text.replace(cx, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a)</span> {</span>
              <span class="hljs-keyword">return</span> <span class="hljs-string">'\\u'</span> +
                  (<span class="hljs-string">'0000'</span> + a.charCodeAt(<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>)).slice(-<span class="hljs-number">4</span>);
          });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>In the second stage, we run the text against regular expressions that look
for non-JSON patterns. We are especially concerned with ‘()’ and ‘new’
because they can cause invocation, and ‘=’ because it can cause mutation.
But just to be safe, we want to reject all unexpected forms.</p>

            </div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>We split the second stage into 4 regexp operations in order to work around
crippling inefficiencies in IE’s and Safari’s regexp engines. First we
replace the JSON backslash pairs with ‘@’ (a non-JSON character). Second, we
replace all simple value tokens with ‘]’ characters. Third, we delete all
open brackets that follow a colon or comma or that begin the text. Finally,
we look to see that the remaining characters are only whitespace or ‘]’ or
‘,’ or ‘:’ or ‘{‘ or ‘}’. If that is so, then the text is safe for eval.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^[\],:{}\s]*$/</span>
              .test(text.replace(<span class="hljs-regexp">/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g</span>, <span class="hljs-string">'@'</span>)
                  .replace(<span class="hljs-regexp">/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>, <span class="hljs-string">']'</span>)
                  .replace(<span class="hljs-regexp">/(?:^|:|,)(?:\s*\[)+/g</span>, <span class="hljs-string">''</span>))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>In the third stage we use the eval function to compile the text into a
JavaScript structure. The ‘{‘ operator is subject to a syntactic ambiguity
in JavaScript: it can begin a block or an object literal. We wrap the text
in parens to eliminate the ambiguity.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          j = <span class="hljs-built_in">eval</span>(<span class="hljs-string">'('</span> + text + <span class="hljs-string">')'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>In the optional fourth stage, we recursively walk the new structure, passing
each name/value pair to a reviver function for possible transformation.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> reviver === <span class="hljs-string">'function'</span> ?
              walk({<span class="hljs-string">''</span>: j}, <span class="hljs-string">''</span>) : j;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>If the text is not JSON parseable, then a SyntaxError is thrown.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">SyntaxError</span>(<span class="hljs-string">'JSON.parse'</span>);
  };

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.exports
  , <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">JSON</span> !== <span class="hljs-string">'undefined'</span> ? <span class="hljs-built_in">JSON</span> : <span class="hljs-literal">undefined</span>
);

<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io)</span> {</span>

  <span class="hljs-comment">/**
   * Parser namespace.
   *
   * @namespace
   */</span>

  <span class="hljs-keyword">var</span> parser = exports.parser = {};

  <span class="hljs-comment">/**
   * Packet types.
   */</span>

  <span class="hljs-keyword">var</span> packets = parser.packets = [
      <span class="hljs-string">'disconnect'</span>
    , <span class="hljs-string">'connect'</span>
    , <span class="hljs-string">'heartbeat'</span>
    , <span class="hljs-string">'message'</span>
    , <span class="hljs-string">'json'</span>
    , <span class="hljs-string">'event'</span>
    , <span class="hljs-string">'ack'</span>
    , <span class="hljs-string">'error'</span>
    , <span class="hljs-string">'noop'</span>
  ];

  <span class="hljs-comment">/**
   * Errors reasons.
   */</span>

  <span class="hljs-keyword">var</span> reasons = parser.reasons = [
      <span class="hljs-string">'transport not supported'</span>
    , <span class="hljs-string">'client not handshaken'</span>
    , <span class="hljs-string">'unauthorized'</span>
  ];

  <span class="hljs-comment">/**
   * Errors advice.
   */</span>

  <span class="hljs-keyword">var</span> advice = parser.advice = [
      <span class="hljs-string">'reconnect'</span>
  ];

  <span class="hljs-comment">/**
   * Shortcuts.
   */</span>

  <span class="hljs-keyword">var</span> <span class="hljs-built_in">JSON</span> = io.JSON
    , indexOf = io.util.indexOf;

  <span class="hljs-comment">/**
   * Encodes a packet.
   *
   * @api private
   */</span>

  parser.encodePacket = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packet)</span> {</span>
    <span class="hljs-keyword">var</span> type = indexOf(packets, packet.type)
      , id = packet.id || <span class="hljs-string">''</span>
      , endpoint = packet.endpoint || <span class="hljs-string">''</span>
      , ack = packet.ack
      , data = <span class="hljs-literal">null</span>;

    <span class="hljs-keyword">switch</span> (packet.type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'error'</span>:
        <span class="hljs-keyword">var</span> reason = packet.reason ? indexOf(reasons, packet.reason) : <span class="hljs-string">''</span>
          , adv = packet.advice ? indexOf(advice, packet.advice) : <span class="hljs-string">''</span>;

        <span class="hljs-keyword">if</span> (reason !== <span class="hljs-string">''</span> || adv !== <span class="hljs-string">''</span>)
          data = reason + (adv !== <span class="hljs-string">''</span> ? (<span class="hljs-string">'+'</span> + adv) : <span class="hljs-string">''</span>);

        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'message'</span>:
        <span class="hljs-keyword">if</span> (packet.data !== <span class="hljs-string">''</span>)
          data = packet.data;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'event'</span>:
        <span class="hljs-keyword">var</span> ev = { name: packet.name };

        <span class="hljs-keyword">if</span> (packet.args &amp;&amp; packet.args.length) {
          ev.args = packet.args;
        }

        data = <span class="hljs-built_in">JSON</span>.stringify(ev);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'json'</span>:
        data = <span class="hljs-built_in">JSON</span>.stringify(packet.data);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'connect'</span>:
        <span class="hljs-keyword">if</span> (packet.qs)
          data = packet.qs;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ack'</span>:
        data = packet.ackId
          + (packet.args &amp;&amp; packet.args.length
              ? <span class="hljs-string">'+'</span> + <span class="hljs-built_in">JSON</span>.stringify(packet.args) : <span class="hljs-string">''</span>);
        <span class="hljs-keyword">break</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>construct packet with required fragments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> encoded = [
        type
      , id + (ack == <span class="hljs-string">'data'</span> ? <span class="hljs-string">'+'</span> : <span class="hljs-string">''</span>)
      , endpoint
    ];</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>data fragment is optional</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (data !== <span class="hljs-literal">null</span> &amp;&amp; data !== <span class="hljs-literal">undefined</span>)
      encoded.push(data);

    <span class="hljs-keyword">return</span> encoded.join(<span class="hljs-string">':'</span>);
  };

  <span class="hljs-comment">/**
   * Encodes multiple messages (payload).
   *
   * @param {Array} messages
   * @api private
   */</span>

  parser.encodePayload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packets)</span> {</span>
    <span class="hljs-keyword">var</span> decoded = <span class="hljs-string">''</span>;

    <span class="hljs-keyword">if</span> (packets.length == <span class="hljs-number">1</span>)
      <span class="hljs-keyword">return</span> packets[<span class="hljs-number">0</span>];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = packets.length; i &lt; l; i++) {
      <span class="hljs-keyword">var</span> packet = packets[i];
      decoded += <span class="hljs-string">'\ufffd'</span> + packet.length + <span class="hljs-string">'\ufffd'</span> + packets[i];
    }

    <span class="hljs-keyword">return</span> decoded;
  };

  <span class="hljs-comment">/**
   * Decodes a packet
   *
   * @api private
   */</span>

  <span class="hljs-keyword">var</span> regexp = <span class="hljs-regexp">/([^:]+):([0-9]+)?(\+)?:([^:]+)?:?([\s\S]*)?/</span>;

  parser.decodePacket = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
    <span class="hljs-keyword">var</span> pieces = data.match(regexp);

    <span class="hljs-keyword">if</span> (!pieces) <span class="hljs-keyword">return</span> {};

    <span class="hljs-keyword">var</span> id = pieces[<span class="hljs-number">2</span>] || <span class="hljs-string">''</span>
      , data = pieces[<span class="hljs-number">5</span>] || <span class="hljs-string">''</span>
      , packet = {
            type: packets[pieces[<span class="hljs-number">1</span>]]
          , endpoint: pieces[<span class="hljs-number">4</span>] || <span class="hljs-string">''</span>
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>whether we need to acknowledge the packet</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (id) {
      packet.id = id;
      <span class="hljs-keyword">if</span> (pieces[<span class="hljs-number">3</span>])
        packet.ack = <span class="hljs-string">'data'</span>;
      <span class="hljs-keyword">else</span>
        packet.ack = <span class="hljs-literal">true</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>handle different packet types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">switch</span> (packet.type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'error'</span>:
        <span class="hljs-keyword">var</span> pieces = data.split(<span class="hljs-string">'+'</span>);
        packet.reason = reasons[pieces[<span class="hljs-number">0</span>]] || <span class="hljs-string">''</span>;
        packet.advice = advice[pieces[<span class="hljs-number">1</span>]] || <span class="hljs-string">''</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'message'</span>:
        packet.data = data || <span class="hljs-string">''</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'event'</span>:
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">var</span> opts = <span class="hljs-built_in">JSON</span>.parse(data);
          packet.name = opts.name;
          packet.args = opts.args;
        } <span class="hljs-keyword">catch</span> (e) { }

        packet.args = packet.args || [];
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'json'</span>:
        <span class="hljs-keyword">try</span> {
          packet.data = <span class="hljs-built_in">JSON</span>.parse(data);
        } <span class="hljs-keyword">catch</span> (e) { }
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'connect'</span>:
        packet.qs = data || <span class="hljs-string">''</span>;
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ack'</span>:
        <span class="hljs-keyword">var</span> pieces = data.match(<span class="hljs-regexp">/^([0-9]+)(\+)?(.*)/</span>);
        <span class="hljs-keyword">if</span> (pieces) {
          packet.ackId = pieces[<span class="hljs-number">1</span>];
          packet.args = [];

          <span class="hljs-keyword">if</span> (pieces[<span class="hljs-number">3</span>]) {
            <span class="hljs-keyword">try</span> {
              packet.args = pieces[<span class="hljs-number">3</span>] ? <span class="hljs-built_in">JSON</span>.parse(pieces[<span class="hljs-number">3</span>]) : [];
            } <span class="hljs-keyword">catch</span> (e) { }
          }
        }
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'disconnect'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'heartbeat'</span>:
        <span class="hljs-keyword">break</span>;
    };

    <span class="hljs-keyword">return</span> packet;
  };

  <span class="hljs-comment">/**
   * Decodes data payload. Detects multiple messages
   *
   * @return {Array} messages
   * @api public
   */</span>

  parser.decodePayload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>IE doesn’t like data[i] for unicode chars, charAt works fine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (data.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">'\ufffd'</span>) {
      <span class="hljs-keyword">var</span> ret = [];

      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, length = <span class="hljs-string">''</span>; i &lt; data.length; i++) {
        <span class="hljs-keyword">if</span> (data.charAt(i) == <span class="hljs-string">'\ufffd'</span>) {
          ret.push(parser.decodePacket(data.substr(i + <span class="hljs-number">1</span>).substr(<span class="hljs-number">0</span>, length)));
          i += <span class="hljs-built_in">Number</span>(length) + <span class="hljs-number">1</span>;
          length = <span class="hljs-string">''</span>;
        } <span class="hljs-keyword">else</span> {
          length += data.charAt(i);
        }
      }

      <span class="hljs-keyword">return</span> ret;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span> [parser.decodePacket(data)];
    }
  };

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
);
<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io)</span> {</span>

  <span class="hljs-comment">/**
   * Expose constructor.
   */</span>

  exports.Transport = Transport;

  <span class="hljs-comment">/**
   * This is the transport template for all supported transport methods.
   *
   * @constructor
   * @api public
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Transport</span> <span class="hljs-params">(socket, sessid)</span> {</span>
    <span class="hljs-keyword">this</span>.socket = socket;
    <span class="hljs-keyword">this</span>.sessid = sessid;
  };

  <span class="hljs-comment">/**
   * Apply EventEmitter mixin.
   */</span>

  io.util.mixin(Transport, io.EventEmitter);


  <span class="hljs-comment">/**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */</span>

  Transport.prototype.heartbeats = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };

  <span class="hljs-comment">/**
   * Handles the response from the server. When a new response is received
   * it will automatically update the timeout, decode the message and
   * forwards the response to the onMessage function for further processing.
   *
   * @param {String} data Response from the server.
   * @api private
   */</span>

  Transport.prototype.onData = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
    <span class="hljs-keyword">this</span>.clearCloseTimeout();</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>If the connection in currently open (or in a reopening state) reset the close
timeout since we have just received data. This check is necessary so
that we don’t reset the timeout on an explicitly disconnected connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.socket.connected || <span class="hljs-keyword">this</span>.socket.connecting || <span class="hljs-keyword">this</span>.socket.reconnecting) {
      <span class="hljs-keyword">this</span>.setCloseTimeout();
    }

    <span class="hljs-keyword">if</span> (data !== <span class="hljs-string">''</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>todo: we should only do decodePayload for xhr transports</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> msgs = io.parser.decodePayload(data);

      <span class="hljs-keyword">if</span> (msgs &amp;&amp; msgs.length) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = msgs.length; i &lt; l; i++) {
          <span class="hljs-keyword">this</span>.onPacket(msgs[i]);
        }
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Handles packets.
   *
   * @api private
   */</span>

  Transport.prototype.onPacket = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packet)</span> {</span>
    <span class="hljs-keyword">this</span>.socket.setHeartbeatTimeout();

    <span class="hljs-keyword">if</span> (packet.type == <span class="hljs-string">'heartbeat'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.onHeartbeat();
    }

    <span class="hljs-keyword">if</span> (packet.type == <span class="hljs-string">'connect'</span> &amp;&amp; packet.endpoint == <span class="hljs-string">''</span>) {
      <span class="hljs-keyword">this</span>.onConnect();
    }

    <span class="hljs-keyword">if</span> (packet.type == <span class="hljs-string">'error'</span> &amp;&amp; packet.advice == <span class="hljs-string">'reconnect'</span>) {
      <span class="hljs-keyword">this</span>.isOpen = <span class="hljs-literal">false</span>;
    }

    <span class="hljs-keyword">this</span>.socket.onPacket(packet);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Sets close timeout
   *
   * @api private
   */</span>

  Transport.prototype.setCloseTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.closeTimeout) {
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

      <span class="hljs-keyword">this</span>.closeTimeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        self.onDisconnect();
      }, <span class="hljs-keyword">this</span>.socket.closeTimeout);
    }
  };

  <span class="hljs-comment">/**
   * Called when transport disconnects.
   *
   * @api private
   */</span>

  Transport.prototype.onDisconnect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isOpen) <span class="hljs-keyword">this</span>.close();
    <span class="hljs-keyword">this</span>.clearTimeouts();
    <span class="hljs-keyword">this</span>.socket.onDisconnect();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Called when transport connects
   *
   * @api private
   */</span>

  Transport.prototype.onConnect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.socket.onConnect();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Clears close timeout
   *
   * @api private
   */</span>

  Transport.prototype.clearCloseTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.closeTimeout) {
      clearTimeout(<span class="hljs-keyword">this</span>.closeTimeout);
      <span class="hljs-keyword">this</span>.closeTimeout = <span class="hljs-literal">null</span>;
    }
  };

  <span class="hljs-comment">/**
   * Clear timeouts
   *
   * @api private
   */</span>

  Transport.prototype.clearTimeouts = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.clearCloseTimeout();

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reopenTimeout) {
      clearTimeout(<span class="hljs-keyword">this</span>.reopenTimeout);
    }
  };

  <span class="hljs-comment">/**
   * Sends a packet
   *
   * @param {Object} packet object.
   * @api private
   */</span>

  Transport.prototype.packet = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packet)</span> {</span>
    <span class="hljs-keyword">this</span>.send(io.parser.encodePacket(packet));
  };

  <span class="hljs-comment">/**
   * Send the received heartbeat message back to server. So the server
   * knows we are still connected.
   *
   * @param {String} heartbeat Heartbeat response from the server.
   * @api private
   */</span>

  Transport.prototype.onHeartbeat = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(heartbeat)</span> {</span>
    <span class="hljs-keyword">this</span>.packet({ type: <span class="hljs-string">'heartbeat'</span> });
  };

  <span class="hljs-comment">/**
   * Called when the transport opens.
   *
   * @api private
   */</span>

  Transport.prototype.onOpen = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.isOpen = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.clearCloseTimeout();
    <span class="hljs-keyword">this</span>.socket.onOpen();
  };

  <span class="hljs-comment">/**
   * Notifies the base when the connection with the Socket.IO server
   * has been disconnected.
   *
   * @api private
   */</span>

  Transport.prototype.onClose = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    <span class="hljs-comment">/* FIXME: reopen delay causing a infinit loop
    this.reopenTimeout = setTimeout(function () {
      self.open();
    }, this.socket.options['reopen delay']);*/</span>

    <span class="hljs-keyword">this</span>.isOpen = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.socket.onClose();
    <span class="hljs-keyword">this</span>.onDisconnect();
  };

  <span class="hljs-comment">/**
   * Generates a connection url based on the Socket.IO URL Protocol.
   * See &lt;https://github.com/learnboost/socket.io-node/&gt; for more details.
   *
   * @returns {String} Connection url
   * @api private
   */</span>

  Transport.prototype.prepareUrl = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> options = <span class="hljs-keyword">this</span>.socket.options;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.scheme() + <span class="hljs-string">'://'</span>
      + options.host + <span class="hljs-string">':'</span> + options.port + <span class="hljs-string">'/'</span>
      + options.resource + <span class="hljs-string">'/'</span> + io.protocol
      + <span class="hljs-string">'/'</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">'/'</span> + <span class="hljs-keyword">this</span>.sessid;
  };

  <span class="hljs-comment">/**
   * Checks if the transport is ready to start a connection.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */</span>

  Transport.prototype.ready = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(socket, fn)</span> {</span>
    fn.call(<span class="hljs-keyword">this</span>);
  };
})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
);
<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io, global)</span> {</span>

  <span class="hljs-comment">/**
   * Expose constructor.
   */</span>

  exports.Socket = Socket;

  <span class="hljs-comment">/**
   * Create a new `Socket.IO client` which can establish a persistent
   * connection with a Socket.IO enabled server.
   *
   * @api public
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Socket</span> <span class="hljs-params">(options)</span> {</span>
    <span class="hljs-keyword">this</span>.options = {
        port: <span class="hljs-number">80</span>
      , secure: <span class="hljs-literal">false</span>
      , document: <span class="hljs-string">'document'</span> <span class="hljs-keyword">in</span> global ? document : <span class="hljs-literal">false</span>
      , resource: <span class="hljs-string">'socket.io'</span>
      , transports: io.transports
      , <span class="hljs-string">'connect timeout'</span>: <span class="hljs-number">10000</span>
      , <span class="hljs-string">'try multiple transports'</span>: <span class="hljs-literal">true</span>
      , <span class="hljs-string">'reconnect'</span>: <span class="hljs-literal">true</span>
      , <span class="hljs-string">'reconnection delay'</span>: <span class="hljs-number">500</span>
      , <span class="hljs-string">'reconnection limit'</span>: <span class="hljs-literal">Infinity</span>
      , <span class="hljs-string">'reopen delay'</span>: <span class="hljs-number">3000</span>
      , <span class="hljs-string">'max reconnection attempts'</span>: <span class="hljs-number">10</span>
      , <span class="hljs-string">'sync disconnect on unload'</span>: <span class="hljs-literal">false</span>
      , <span class="hljs-string">'auto connect'</span>: <span class="hljs-literal">true</span>
      , <span class="hljs-string">'flash policy port'</span>: <span class="hljs-number">10843</span>
      , <span class="hljs-string">'manualFlush'</span>: <span class="hljs-literal">false</span>
    };

    io.util.merge(<span class="hljs-keyword">this</span>.options, options);

    <span class="hljs-keyword">this</span>.connected = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.open = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.connecting = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.reconnecting = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.namespaces = {};
    <span class="hljs-keyword">this</span>.buffer = [];
    <span class="hljs-keyword">this</span>.doBuffer = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options[<span class="hljs-string">'sync disconnect on unload'</span>] &amp;&amp;
        (!<span class="hljs-keyword">this</span>.isXDomain() || io.util.ua.hasCORS)) {
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
      io.util.on(global, <span class="hljs-string">'beforeunload'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        self.disconnectSync();
      }, <span class="hljs-literal">false</span>);
    }

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options[<span class="hljs-string">'auto connect'</span>]) {
      <span class="hljs-keyword">this</span>.connect();
    }
};

  <span class="hljs-comment">/**
   * Apply EventEmitter mixin.
   */</span>

  io.util.mixin(Socket, io.EventEmitter);

  <span class="hljs-comment">/**
   * Returns a namespace listener/emitter for this socket
   *
   * @api public
   */</span>

  Socket.prototype.of = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.namespaces[name]) {
      <span class="hljs-keyword">this</span>.namespaces[name] = <span class="hljs-keyword">new</span> io.SocketNamespace(<span class="hljs-keyword">this</span>, name);

      <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">''</span>) {
        <span class="hljs-keyword">this</span>.namespaces[name].packet({ type: <span class="hljs-string">'connect'</span> });
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.namespaces[name];
  };

  <span class="hljs-comment">/**
   * Emits the given event to the Socket and all namespaces
   *
   * @api private
   */</span>

  Socket.prototype.publish = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.emit.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

    <span class="hljs-keyword">var</span> nsp;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.namespaces) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.namespaces.hasOwnProperty(i)) {
        nsp = <span class="hljs-keyword">this</span>.of(i);
        nsp.$emit.apply(nsp, <span class="hljs-built_in">arguments</span>);
      }
    }
  };

  <span class="hljs-comment">/**
   * Performs the handshake
   *
   * @api private
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">empty</span> <span class="hljs-params">()</span> {</span> };

  Socket.prototype.handshake = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
      , options = <span class="hljs-keyword">this</span>.options;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">complete</span> <span class="hljs-params">(data)</span> {</span>
      <span class="hljs-keyword">if</span> (data <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Error</span>) {
        self.connecting = <span class="hljs-literal">false</span>;
        self.onError(data.message);
      } <span class="hljs-keyword">else</span> {
        fn.apply(<span class="hljs-literal">null</span>, data.split(<span class="hljs-string">':'</span>));
      }
    };

    <span class="hljs-keyword">var</span> url = [
          <span class="hljs-string">'http'</span> + (options.secure ? <span class="hljs-string">'s'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">':/'</span>
        , options.host + <span class="hljs-string">':'</span> + options.port
        , options.resource
        , io.protocol
        , io.util.query(<span class="hljs-keyword">this</span>.options.query, <span class="hljs-string">'t='</span> + +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>)
      ].join(<span class="hljs-string">'/'</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isXDomain() &amp;&amp; !io.util.ua.hasCORS) {
      <span class="hljs-keyword">var</span> insertAt = document.getElementsByTagName(<span class="hljs-string">'script'</span>)[<span class="hljs-number">0</span>]
        , script = document.createElement(<span class="hljs-string">'script'</span>);

      script.src = url + <span class="hljs-string">'&amp;jsonp='</span> + io.j.length;
      insertAt.parentNode.insertBefore(script, insertAt);

      io.j.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
        complete(data);
        script.parentNode.removeChild(script);
      });
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">var</span> xhr = io.util.request();

      xhr.open(<span class="hljs-string">'GET'</span>, url, <span class="hljs-literal">true</span>);
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isXDomain()) {
        xhr.withCredentials = <span class="hljs-literal">true</span>;
      }
      xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (xhr.readyState == <span class="hljs-number">4</span>) {
          xhr.onreadystatechange = empty;

          <span class="hljs-keyword">if</span> (xhr.status == <span class="hljs-number">200</span>) {
            complete(xhr.responseText);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (xhr.status == <span class="hljs-number">403</span>) {
            self.onError(xhr.responseText);
          } <span class="hljs-keyword">else</span> {
            self.connecting = <span class="hljs-literal">false</span>;            
            !self.reconnecting &amp;&amp; self.onError(xhr.responseText);
          }
        }
      };
      xhr.send(<span class="hljs-literal">null</span>);
    }
  };

  <span class="hljs-comment">/**
   * Find an available transport based on the options supplied in the constructor.
   *
   * @api private
   */</span>

  Socket.prototype.getTransport = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(override)</span> {</span>
    <span class="hljs-keyword">var</span> transports = override || <span class="hljs-keyword">this</span>.transports, match;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, transport; transport = transports[i]; i++) {
      <span class="hljs-keyword">if</span> (io.Transport[transport]
        &amp;&amp; io.Transport[transport].check(<span class="hljs-keyword">this</span>)
        &amp;&amp; (!<span class="hljs-keyword">this</span>.isXDomain() || io.Transport[transport].xdomainCheck(<span class="hljs-keyword">this</span>))) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> io.Transport[transport](<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.sessionid);
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  };

  <span class="hljs-comment">/**
   * Connects to the server.
   *
   * @param {Function} [fn] Callback.
   * @returns {io.Socket}
   * @api public
   */</span>

  Socket.prototype.connect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(fn)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connecting) {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    }

    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    self.connecting = <span class="hljs-literal">true</span>;
    
    <span class="hljs-keyword">this</span>.handshake(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(sid, heartbeat, close, transports)</span> {</span>
      self.sessionid = sid;
      self.closeTimeout = close * <span class="hljs-number">1000</span>;
      self.heartbeatTimeout = heartbeat * <span class="hljs-number">1000</span>;
      <span class="hljs-keyword">if</span>(!self.transports)
          self.transports = self.origTransports = (transports ? io.util.intersect(
              transports.split(<span class="hljs-string">','</span>)
            , self.options.transports
          ) : self.options.transports);

      self.setHeartbeatTimeout();

      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connect</span> <span class="hljs-params">(transports)</span>{</span>
        <span class="hljs-keyword">if</span> (self.transport) self.transport.clearTimeouts();

        self.transport = self.getTransport(transports);
        <span class="hljs-keyword">if</span> (!self.transport) <span class="hljs-keyword">return</span> self.publish(<span class="hljs-string">'connect_failed'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>once the transport is ready</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        self.transport.ready(self, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
          self.connecting = <span class="hljs-literal">true</span>;
          self.publish(<span class="hljs-string">'connecting'</span>, self.transport.name);
          self.transport.open();

          <span class="hljs-keyword">if</span> (self.options[<span class="hljs-string">'connect timeout'</span>]) {
            self.connectTimeoutTimer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
              <span class="hljs-keyword">if</span> (!self.connected) {
                self.connecting = <span class="hljs-literal">false</span>;

                <span class="hljs-keyword">if</span> (self.options[<span class="hljs-string">'try multiple transports'</span>]) {
                  <span class="hljs-keyword">var</span> remaining = self.transports;

                  <span class="hljs-keyword">while</span> (remaining.length &gt; <span class="hljs-number">0</span> &amp;&amp; remaining.splice(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] !=
                         self.transport.name) {}

                    <span class="hljs-keyword">if</span> (remaining.length){
                      connect(remaining);
                    } <span class="hljs-keyword">else</span> {
                      self.publish(<span class="hljs-string">'connect_failed'</span>);
                    }
                }
              }
            }, self.options[<span class="hljs-string">'connect timeout'</span>]);
          }
        });
      }

      connect(self.transports);

      self.once(<span class="hljs-string">'connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span>{</span>
        clearTimeout(self.connectTimeoutTimer);

        fn &amp;&amp; <span class="hljs-keyword">typeof</span> fn == <span class="hljs-string">'function'</span> &amp;&amp; fn();
      });
    });

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Clears and sets a new heartbeat timeout using the value given by the
   * server during the handshake.
   *
   * @api private
   */</span>

  Socket.prototype.setHeartbeatTimeout = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    clearTimeout(<span class="hljs-keyword">this</span>.heartbeatTimeoutTimer);
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.transport &amp;&amp; !<span class="hljs-keyword">this</span>.transport.heartbeats()) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.heartbeatTimeoutTimer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      self.transport.onClose();
    }, <span class="hljs-keyword">this</span>.heartbeatTimeout);
  };

  <span class="hljs-comment">/**
   * Sends a message.
   *
   * @param {Object} data packet.
   * @returns {io.Socket}
   * @api public
   */</span>

  Socket.prototype.packet = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connected &amp;&amp; !<span class="hljs-keyword">this</span>.doBuffer) {
      <span class="hljs-keyword">this</span>.transport.packet(data);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.buffer.push(data);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Sets buffer state
   *
   * @api private
   */</span>

  Socket.prototype.setBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(v)</span> {</span>
    <span class="hljs-keyword">this</span>.doBuffer = v;

    <span class="hljs-keyword">if</span> (!v &amp;&amp; <span class="hljs-keyword">this</span>.connected &amp;&amp; <span class="hljs-keyword">this</span>.buffer.length) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.options[<span class="hljs-string">'manualFlush'</span>]) {
        <span class="hljs-keyword">this</span>.flushBuffer();
      }
    }
  };

  <span class="hljs-comment">/**
   * Flushes the buffer data over the wire.
   * To be invoked manually when 'manualFlush' is set to true.
   *
   * @api public
   */</span>

  Socket.prototype.flushBuffer = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.transport.payload(<span class="hljs-keyword">this</span>.buffer);
    <span class="hljs-keyword">this</span>.buffer = [];
  };
  

  <span class="hljs-comment">/**
   * Disconnect the established connect.
   *
   * @returns {io.Socket}
   * @api public
   */</span>

  Socket.prototype.disconnect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connected || <span class="hljs-keyword">this</span>.connecting) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.open) {
        <span class="hljs-keyword">this</span>.of(<span class="hljs-string">''</span>).packet({ type: <span class="hljs-string">'disconnect'</span> });
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>handle disconnection immediately</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.onDisconnect(<span class="hljs-string">'booted'</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Disconnects the socket with a sync XHR.
   *
   * @api private
   */</span>

  Socket.prototype.disconnectSync = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>ensure disconnection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> xhr = io.util.request();
    <span class="hljs-keyword">var</span> uri = [
        <span class="hljs-string">'http'</span> + (<span class="hljs-keyword">this</span>.options.secure ? <span class="hljs-string">'s'</span> : <span class="hljs-string">''</span>) + <span class="hljs-string">':/'</span>
      , <span class="hljs-keyword">this</span>.options.host + <span class="hljs-string">':'</span> + <span class="hljs-keyword">this</span>.options.port
      , <span class="hljs-keyword">this</span>.options.resource
      , io.protocol
      , <span class="hljs-string">''</span>
      , <span class="hljs-keyword">this</span>.sessionid
    ].join(<span class="hljs-string">'/'</span>) + <span class="hljs-string">'/?disconnect=1'</span>;

    xhr.open(<span class="hljs-string">'GET'</span>, uri, <span class="hljs-literal">false</span>);
    xhr.send(<span class="hljs-literal">null</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>handle disconnection immediately</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.onDisconnect(<span class="hljs-string">'booted'</span>);
  };

  <span class="hljs-comment">/**
   * Check if we need to use cross domain enabled transports. Cross domain would
   * be a different port or different domain name.
   *
   * @returns {Boolean}
   * @api private
   */</span>

  Socket.prototype.isXDomain = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">var</span> port = global.location.port ||
      (<span class="hljs-string">'https:'</span> == global.location.protocol ? <span class="hljs-number">443</span> : <span class="hljs-number">80</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.options.host !== global.location.hostname 
      || <span class="hljs-keyword">this</span>.options.port != port;
  };

  <span class="hljs-comment">/**
   * Called upon handshake.
   *
   * @api private
   */</span>

  Socket.prototype.onConnect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.connected) {
      <span class="hljs-keyword">this</span>.connected = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.connecting = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.doBuffer) {</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>make sure to flush the buffer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">this</span>.setBuffer(<span class="hljs-literal">false</span>);
      }
      <span class="hljs-keyword">this</span>.emit(<span class="hljs-string">'connect'</span>);
    }
  };

  <span class="hljs-comment">/**
   * Called when the transport opens
   *
   * @api private
   */</span>

  Socket.prototype.onOpen = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.open = <span class="hljs-literal">true</span>;
  };

  <span class="hljs-comment">/**
   * Called when the transport closes.
   *
   * @api private
   */</span>

  Socket.prototype.onClose = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.open = <span class="hljs-literal">false</span>;
    clearTimeout(<span class="hljs-keyword">this</span>.heartbeatTimeoutTimer);
  };

  <span class="hljs-comment">/**
   * Called when the transport first opens a connection
   *
   * @param text
   */</span>

  Socket.prototype.onPacket = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packet)</span> {</span>
    <span class="hljs-keyword">this</span>.of(packet.endpoint).onPacket(packet);
  };

  <span class="hljs-comment">/**
   * Handles an error.
   *
   * @api private
   */</span>

  Socket.prototype.onError = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(err)</span> {</span>
    <span class="hljs-keyword">if</span> (err &amp;&amp; err.advice) {
      <span class="hljs-keyword">if</span> (err.advice === <span class="hljs-string">'reconnect'</span> &amp;&amp; (<span class="hljs-keyword">this</span>.connected || <span class="hljs-keyword">this</span>.connecting)) {
        <span class="hljs-keyword">this</span>.disconnect();
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.options.reconnect) {
          <span class="hljs-keyword">this</span>.reconnect();
        }
      }
    }

    <span class="hljs-keyword">this</span>.publish(<span class="hljs-string">'error'</span>, err &amp;&amp; err.reason ? err.reason : err);
  };

  <span class="hljs-comment">/**
   * Called when the transport disconnects.
   *
   * @api private
   */</span>

  Socket.prototype.onDisconnect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(reason)</span> {</span>
    <span class="hljs-keyword">var</span> wasConnected = <span class="hljs-keyword">this</span>.connected
      , wasConnecting = <span class="hljs-keyword">this</span>.connecting;

    <span class="hljs-keyword">this</span>.connected = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.connecting = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.open = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">if</span> (wasConnected || wasConnecting) {
      <span class="hljs-keyword">this</span>.transport.close();
      <span class="hljs-keyword">this</span>.transport.clearTimeouts();
      <span class="hljs-keyword">if</span> (wasConnected) {
        <span class="hljs-keyword">this</span>.publish(<span class="hljs-string">'disconnect'</span>, reason);

        <span class="hljs-keyword">if</span> (<span class="hljs-string">'booted'</span> != reason &amp;&amp; <span class="hljs-keyword">this</span>.options.reconnect &amp;&amp; !<span class="hljs-keyword">this</span>.reconnecting) {
          <span class="hljs-keyword">this</span>.reconnect();
        }
      }
    }
  };

  <span class="hljs-comment">/**
   * Called upon reconnection.
   *
   * @api private
   */</span>

  Socket.prototype.reconnect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.reconnecting = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.reconnectionAttempts = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.reconnectionDelay = <span class="hljs-keyword">this</span>.options[<span class="hljs-string">'reconnection delay'</span>];

    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
      , maxAttempts = <span class="hljs-keyword">this</span>.options[<span class="hljs-string">'max reconnection attempts'</span>]
      , tryMultiple = <span class="hljs-keyword">this</span>.options[<span class="hljs-string">'try multiple transports'</span>]
      , limit = <span class="hljs-keyword">this</span>.options[<span class="hljs-string">'reconnection limit'</span>];

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (self.connected) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> self.namespaces) {
          <span class="hljs-keyword">if</span> (self.namespaces.hasOwnProperty(i) &amp;&amp; <span class="hljs-string">''</span> !== i) {
              self.namespaces[i].packet({ type: <span class="hljs-string">'connect'</span> });
          }
        }
        self.publish(<span class="hljs-string">'reconnect'</span>, self.transport.name, self.reconnectionAttempts);
      }

      clearTimeout(self.reconnectionTimer);

      self.removeListener(<span class="hljs-string">'connect_failed'</span>, maybeReconnect);
      self.removeListener(<span class="hljs-string">'connect'</span>, maybeReconnect);

      self.reconnecting = <span class="hljs-literal">false</span>;

      <span class="hljs-keyword">delete</span> self.reconnectionAttempts;
      <span class="hljs-keyword">delete</span> self.reconnectionDelay;
      <span class="hljs-keyword">delete</span> self.reconnectionTimer;
      <span class="hljs-keyword">delete</span> self.redoTransports;

      self.options[<span class="hljs-string">'try multiple transports'</span>] = tryMultiple;
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maybeReconnect</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (!self.reconnecting) {
        <span class="hljs-keyword">return</span>;
      }

      <span class="hljs-keyword">if</span> (self.connected) {
        <span class="hljs-keyword">return</span> reset();
      };

      <span class="hljs-keyword">if</span> (self.connecting &amp;&amp; self.reconnecting) {
        <span class="hljs-keyword">return</span> self.reconnectionTimer = setTimeout(maybeReconnect, <span class="hljs-number">1000</span>);
      }

      <span class="hljs-keyword">if</span> (self.reconnectionAttempts++ &gt;= maxAttempts) {
        <span class="hljs-keyword">if</span> (!self.redoTransports) {
          self.on(<span class="hljs-string">'connect_failed'</span>, maybeReconnect);
          self.options[<span class="hljs-string">'try multiple transports'</span>] = <span class="hljs-literal">true</span>;
          self.transports = self.origTransports;
          self.transport = self.getTransport();
          self.redoTransports = <span class="hljs-literal">true</span>;
          self.connect();
        } <span class="hljs-keyword">else</span> {
          self.publish(<span class="hljs-string">'reconnect_failed'</span>);
          reset();
        }
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (self.reconnectionDelay &lt; limit) {
          self.reconnectionDelay *= <span class="hljs-number">2</span>; <span class="hljs-comment">// exponential back off</span>
        }

        self.connect();
        self.publish(<span class="hljs-string">'reconnecting'</span>, self.reconnectionDelay, self.reconnectionAttempts);
        self.reconnectionTimer = setTimeout(maybeReconnect, self.reconnectionDelay);
      }
    };

    <span class="hljs-keyword">this</span>.options[<span class="hljs-string">'try multiple transports'</span>] = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">this</span>.reconnectionTimer = setTimeout(maybeReconnect, <span class="hljs-keyword">this</span>.reconnectionDelay);

    <span class="hljs-keyword">this</span>.on(<span class="hljs-string">'connect'</span>, maybeReconnect);
  };

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
  , <span class="hljs-keyword">this</span>
);
<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io)</span> {</span>

  <span class="hljs-comment">/**
   * Expose constructor.
   */</span>

  exports.SocketNamespace = SocketNamespace;

  <span class="hljs-comment">/**
   * Socket namespace constructor.
   *
   * @constructor
   * @api public
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SocketNamespace</span> <span class="hljs-params">(socket, name)</span> {</span>
    <span class="hljs-keyword">this</span>.socket = socket;
    <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">''</span>;
    <span class="hljs-keyword">this</span>.flags = {};
    <span class="hljs-keyword">this</span>.json = <span class="hljs-keyword">new</span> Flag(<span class="hljs-keyword">this</span>, <span class="hljs-string">'json'</span>);
    <span class="hljs-keyword">this</span>.ackPackets = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">this</span>.acks = {};
  };

  <span class="hljs-comment">/**
   * Apply EventEmitter mixin.
   */</span>

  io.util.mixin(SocketNamespace, io.EventEmitter);

  <span class="hljs-comment">/**
   * Copies emit since we override it
   *
   * @api private
   */</span>

  SocketNamespace.prototype.$emit = io.EventEmitter.prototype.emit;

  <span class="hljs-comment">/**
   * Creates a new namespace, by proxying the request to the socket. This
   * allows us to use the synax as we do on the server.
   *
   * @api public
   */</span>

  SocketNamespace.prototype.of = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.socket.of.apply(<span class="hljs-keyword">this</span>.socket, <span class="hljs-built_in">arguments</span>);
  };

  <span class="hljs-comment">/**
   * Sends a packet.
   *
   * @api private
   */</span>

  SocketNamespace.prototype.packet = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packet)</span> {</span>
    packet.endpoint = <span class="hljs-keyword">this</span>.name;
    <span class="hljs-keyword">this</span>.socket.packet(packet);
    <span class="hljs-keyword">this</span>.flags = {};
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Sends a message
   *
   * @api public
   */</span>

  SocketNamespace.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, fn)</span> {</span>
    <span class="hljs-keyword">var</span> packet = {
        type: <span class="hljs-keyword">this</span>.flags.json ? <span class="hljs-string">'json'</span> : <span class="hljs-string">'message'</span>
      , data: data
    };

    <span class="hljs-keyword">if</span> (<span class="hljs-string">'function'</span> == <span class="hljs-keyword">typeof</span> fn) {
      packet.id = ++<span class="hljs-keyword">this</span>.ackPackets;
      packet.ack = <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.acks[packet.id] = fn;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.packet(packet);
  };

  <span class="hljs-comment">/**
   * Emits an event
   *
   * @api public
   */</span>
  
  SocketNamespace.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name)</span> {</span>
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)
      , lastArg = args[args.length - <span class="hljs-number">1</span>]
      , packet = {
            type: <span class="hljs-string">'event'</span>
          , name: name
        };

    <span class="hljs-keyword">if</span> (<span class="hljs-string">'function'</span> == <span class="hljs-keyword">typeof</span> lastArg) {
      packet.id = ++<span class="hljs-keyword">this</span>.ackPackets;
      packet.ack = <span class="hljs-string">'data'</span>;
      <span class="hljs-keyword">this</span>.acks[packet.id] = lastArg;
      args = args.slice(<span class="hljs-number">0</span>, args.length - <span class="hljs-number">1</span>);
    }

    packet.args = args;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.packet(packet);
  };

  <span class="hljs-comment">/**
   * Disconnects the namespace
   *
   * @api private
   */</span>

  SocketNamespace.prototype.disconnect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name === <span class="hljs-string">''</span>) {
      <span class="hljs-keyword">this</span>.socket.disconnect();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.packet({ type: <span class="hljs-string">'disconnect'</span> });
      <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'disconnect'</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Handles a packet
   *
   * @api private
   */</span>

  SocketNamespace.prototype.onPacket = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(packet)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ack</span> <span class="hljs-params">()</span> {</span>
      self.packet({
          type: <span class="hljs-string">'ack'</span>
        , args: io.util.toArray(<span class="hljs-built_in">arguments</span>)
        , ackId: packet.id
      });
    };

    <span class="hljs-keyword">switch</span> (packet.type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'connect'</span>:
        <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'connect'</span>);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'disconnect'</span>:
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name === <span class="hljs-string">''</span>) {
          <span class="hljs-keyword">this</span>.socket.onDisconnect(packet.reason || <span class="hljs-string">'booted'</span>);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'disconnect'</span>, packet.reason);
        }
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'message'</span>:
      <span class="hljs-keyword">case</span> <span class="hljs-string">'json'</span>:
        <span class="hljs-keyword">var</span> params = [<span class="hljs-string">'message'</span>, packet.data];

        <span class="hljs-keyword">if</span> (packet.ack == <span class="hljs-string">'data'</span>) {
          params.push(ack);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (packet.ack) {
          <span class="hljs-keyword">this</span>.packet({ type: <span class="hljs-string">'ack'</span>, ackId: packet.id });
        }

        <span class="hljs-keyword">this</span>.$emit.apply(<span class="hljs-keyword">this</span>, params);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'event'</span>:
        <span class="hljs-keyword">var</span> params = [packet.name].concat(packet.args);

        <span class="hljs-keyword">if</span> (packet.ack == <span class="hljs-string">'data'</span>)
          params.push(ack);

        <span class="hljs-keyword">this</span>.$emit.apply(<span class="hljs-keyword">this</span>, params);
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'ack'</span>:
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.acks[packet.ackId]) {
          <span class="hljs-keyword">this</span>.acks[packet.ackId].apply(<span class="hljs-keyword">this</span>, packet.args);
          <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>.acks[packet.ackId];
        }
        <span class="hljs-keyword">break</span>;

      <span class="hljs-keyword">case</span> <span class="hljs-string">'error'</span>:
        <span class="hljs-keyword">if</span> (packet.advice){
          <span class="hljs-keyword">this</span>.socket.onError(packet);
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">if</span> (packet.reason == <span class="hljs-string">'unauthorized'</span>) {
            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'connect_failed'</span>, packet.reason);
          } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'error'</span>, packet.reason);
          }
        }
        <span class="hljs-keyword">break</span>;
    }
  };

  <span class="hljs-comment">/**
   * Flag interface.
   *
   * @api private
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Flag</span> <span class="hljs-params">(nsp, name)</span> {</span>
    <span class="hljs-keyword">this</span>.namespace = nsp;
    <span class="hljs-keyword">this</span>.name = name;
  };

  <span class="hljs-comment">/**
   * Send a message
   *
   * @api public
   */</span>

  Flag.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.namespace.flags[<span class="hljs-keyword">this</span>.name] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.namespace.send.apply(<span class="hljs-keyword">this</span>.namespace, <span class="hljs-built_in">arguments</span>);
  };

  <span class="hljs-comment">/**
   * Emit an event
   *
   * @api public
   */</span>

  Flag.prototype.emit = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.namespace.flags[<span class="hljs-keyword">this</span>.name] = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.namespace.emit.apply(<span class="hljs-keyword">this</span>.namespace, <span class="hljs-built_in">arguments</span>);
  };

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
);

<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io, global)</span> {</span>

  <span class="hljs-comment">/**
   * Expose constructor.
   */</span>

  exports.websocket = WS;

  <span class="hljs-comment">/**
   * The WebSocket transport uses the HTML5 WebSocket API to establish an
   * persistent connection with the Socket.IO server. This transport will also
   * be inherited by the FlashSocket fallback as it provides a API compatible
   * polyfill for the WebSockets.
   *
   * @constructor
   * @extends {io.Transport}
   * @api public
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WS</span> <span class="hljs-params">(socket)</span> {</span>
    io.Transport.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };

  <span class="hljs-comment">/**
   * Inherits from Transport.
   */</span>

  io.util.inherit(WS, io.Transport);

  <span class="hljs-comment">/**
   * Transport name
   *
   * @api public
   */</span>

  WS.prototype.name = <span class="hljs-string">'websocket'</span>;

  <span class="hljs-comment">/**
   * Initializes a new `WebSocket` connection with the Socket.IO server. We attach
   * all the appropriate listeners to handle the responses from the server.
   *
   * @returns {Transport}
   * @api public
   */</span>

  WS.prototype.open = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> query = io.util.query(<span class="hljs-keyword">this</span>.socket.options.query)
      , self = <span class="hljs-keyword">this</span>
      , Socket


    <span class="hljs-keyword">if</span> (!Socket) {
      Socket = global.MozWebSocket || global.WebSocket;
    }

    <span class="hljs-keyword">this</span>.websocket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-keyword">this</span>.prepareUrl() + query);

    <span class="hljs-keyword">this</span>.websocket.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      self.onOpen();
      self.socket.setBuffer(<span class="hljs-literal">false</span>);
    };
    <span class="hljs-keyword">this</span>.websocket.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(ev)</span> {</span>
      self.onData(ev.data);
    };
    <span class="hljs-keyword">this</span>.websocket.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      self.onClose();
      self.socket.setBuffer(<span class="hljs-literal">true</span>);
    };
    <span class="hljs-keyword">this</span>.websocket.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
      self.onError(e);
    };

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Send a message to the Socket.IO server. The message will automatically be
   * encoded in the correct message format.
   *
   * @returns {Transport}
   * @api public
   */</span></pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Do to a bug in the current IDevices browser, we need to wrap the send in a 
setTimeout, when they resume from sleeping the browser will crash if 
we don’t allow the browser time to detect the socket has been closed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (io.util.ua.iDevice) {
    WS.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
      <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
         self.websocket.send(data);
      },<span class="hljs-number">0</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };
  } <span class="hljs-keyword">else</span> {
    WS.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
      <span class="hljs-keyword">this</span>.websocket.send(data);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };
  }

  <span class="hljs-comment">/**
   * Payload
   *
   * @api private
   */</span>

  WS.prototype.payload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arr)</span> {</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = arr.length; i &lt; l; i++) {
      <span class="hljs-keyword">this</span>.packet(arr[i]);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Disconnect the established `WebSocket` connection.
   *
   * @returns {Transport}
   * @api public
   */</span>

  WS.prototype.close = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.websocket.close();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Handle the errors that `WebSocket` might be giving when we
   * are attempting to connect or send messages.
   *
   * @param {Error} e The error.
   * @api private
   */</span>

  WS.prototype.onError = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> {</span>
    <span class="hljs-keyword">this</span>.socket.onError(e);
  };

  <span class="hljs-comment">/**
   * Returns the appropriate scheme for the URI generation.
   *
   * @api private
   */</span>
  WS.prototype.scheme = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.socket.options.secure ? <span class="hljs-string">'wss'</span> : <span class="hljs-string">'ws'</span>;
  };

  <span class="hljs-comment">/**
   * Checks if the browser has support for native `WebSockets` and that
   * it's not the polyfill created for the FlashSocket transport.
   *
   * @return {Boolean}
   * @api public
   */</span>

  WS.check = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-string">'WebSocket'</span> <span class="hljs-keyword">in</span> global &amp;&amp; !(<span class="hljs-string">'__addTask'</span> <span class="hljs-keyword">in</span> WebSocket))
          || <span class="hljs-string">'MozWebSocket'</span> <span class="hljs-keyword">in</span> global;
  };

  <span class="hljs-comment">/**
   * Check if the `WebSocket` transport support cross domain communications.
   *
   * @returns {Boolean}
   * @api public
   */</span>

  WS.xdomainCheck = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };

  <span class="hljs-comment">/**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */</span>

  io.transports.push(<span class="hljs-string">'websocket'</span>);

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io.Transport : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
  , <span class="hljs-keyword">this</span>
);

<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io, global)</span> {</span>

  <span class="hljs-comment">/**
   * Expose constructor.
   *
   * @api public
   */</span>

  exports.XHR = XHR;

  <span class="hljs-comment">/**
   * XHR constructor
   *
   * @costructor
   * @api public
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">XHR</span> <span class="hljs-params">(socket)</span> {</span>
    <span class="hljs-keyword">if</span> (!socket) <span class="hljs-keyword">return</span>;

    io.Transport.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">this</span>.sendBuffer = [];
  };

  <span class="hljs-comment">/**
   * Inherits from Transport.
   */</span>

  io.util.inherit(XHR, io.Transport);

  <span class="hljs-comment">/**
   * Establish a connection
   *
   * @returns {Transport}
   * @api public
   */</span>

  XHR.prototype.open = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.socket.setBuffer(<span class="hljs-literal">false</span>);
    <span class="hljs-keyword">this</span>.onOpen();
    <span class="hljs-keyword">this</span>.get();</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>we need to make sure the request succeeds since we have no indication
whether the request opened or not until it succeeded.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.setCloseTimeout();

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Check if we need to send data to the Socket.IO server, if we have data in our
   * buffer we encode it and forward it to the `post` method.
   *
   * @api private
   */</span>

  XHR.prototype.payload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(payload)</span> {</span>
    <span class="hljs-keyword">var</span> msgs = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = payload.length; i &lt; l; i++) {
      msgs.push(io.parser.encodePacket(payload[i]));
    }

    <span class="hljs-keyword">this</span>.send(io.parser.encodePayload(msgs));
  };

  <span class="hljs-comment">/**
   * Send data to the Socket.IO server.
   *
   * @param data The message
   * @returns {Transport}
   * @api public
   */</span>

  XHR.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
    <span class="hljs-keyword">this</span>.post(data);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Posts a encoded message to the Socket.IO server.
   *
   * @param {String} data A encoded message.
   * @api private
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">empty</span> <span class="hljs-params">()</span> {</span> };

  XHR.prototype.post = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.socket.setBuffer(<span class="hljs-literal">true</span>);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stateChange</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readyState == <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">this</span>.onreadystatechange = empty;
        self.posting = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status == <span class="hljs-number">200</span>){
          self.socket.setBuffer(<span class="hljs-literal">false</span>);
        } <span class="hljs-keyword">else</span> {
          self.onClose();
        }
      }
    }

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onload</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">this</span>.onload = empty;
      self.socket.setBuffer(<span class="hljs-literal">false</span>);
    };

    <span class="hljs-keyword">this</span>.sendXHR = <span class="hljs-keyword">this</span>.request(<span class="hljs-string">'POST'</span>);

    <span class="hljs-keyword">if</span> (global.XDomainRequest &amp;&amp; <span class="hljs-keyword">this</span>.sendXHR <span class="hljs-keyword">instanceof</span> XDomainRequest) {
      <span class="hljs-keyword">this</span>.sendXHR.onload = <span class="hljs-keyword">this</span>.sendXHR.onerror = onload;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.sendXHR.onreadystatechange = stateChange;
    }

    <span class="hljs-keyword">this</span>.sendXHR.send(data);
  };

  <span class="hljs-comment">/**
   * Disconnects the established `XHR` connection.
   *
   * @returns {Transport}
   * @api public
   */</span>

  XHR.prototype.close = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.onClose();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * Generates a configured XHR request
   *
   * @param {String} url The url that needs to be requested.
   * @param {String} method The method the request should use.
   * @returns {XMLHttpRequest}
   * @api private
   */</span>

  XHR.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method)</span> {</span>
    <span class="hljs-keyword">var</span> req = io.util.request(<span class="hljs-keyword">this</span>.socket.isXDomain())
      , query = io.util.query(<span class="hljs-keyword">this</span>.socket.options.query, <span class="hljs-string">'t='</span> + +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>);

    req.open(method || <span class="hljs-string">'GET'</span>, <span class="hljs-keyword">this</span>.prepareUrl() + query, <span class="hljs-literal">true</span>);

    <span class="hljs-keyword">if</span> (method == <span class="hljs-string">'POST'</span>) {
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">if</span> (req.setRequestHeader) {
          req.setRequestHeader(<span class="hljs-string">'Content-type'</span>, <span class="hljs-string">'text/plain;charset=UTF-8'</span>);
        } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>XDomainRequest</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          req.contentType = <span class="hljs-string">'text/plain'</span>;
        }
      } <span class="hljs-keyword">catch</span> (e) {}
    }

    <span class="hljs-keyword">return</span> req;
  };

  <span class="hljs-comment">/**
   * Returns the scheme to use for the transport URLs.
   *
   * @api private
   */</span>

  XHR.prototype.scheme = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.socket.options.secure ? <span class="hljs-string">'https'</span> : <span class="hljs-string">'http'</span>;
  };

  <span class="hljs-comment">/**
   * Check if the XHR transports are supported
   *
   * @param {Boolean} xdomain Check if we support cross domain requests.
   * @returns {Boolean}
   * @api public
   */</span>

  XHR.check = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(socket, xdomain)</span> {</span>
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> request = io.util.request(xdomain),
          usesXDomReq = (global.XDomainRequest &amp;&amp; request <span class="hljs-keyword">instanceof</span> XDomainRequest),
          socketProtocol = (socket &amp;&amp; socket.options &amp;&amp; socket.options.secure ? <span class="hljs-string">'https:'</span> : <span class="hljs-string">'http:'</span>),
          isXProtocol = (global.location &amp;&amp; socketProtocol != global.location.protocol);
      <span class="hljs-keyword">if</span> (request &amp;&amp; !(usesXDomReq &amp;&amp; isXProtocol)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      }
    } <span class="hljs-keyword">catch</span>(e) {}

    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  <span class="hljs-comment">/**
   * Check if the XHR transport supports cross domain requests.
   *
   * @returns {Boolean}
   * @api public
   */</span>

  XHR.xdomainCheck = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(socket)</span> {</span>
    <span class="hljs-keyword">return</span> XHR.check(socket, <span class="hljs-literal">true</span>);
  };

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io.Transport : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
  , <span class="hljs-keyword">this</span>
);
<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io)</span> {</span>

  <span class="hljs-comment">/**
   * Expose constructor.
   */</span>

  exports.htmlfile = HTMLFile;

  <span class="hljs-comment">/**
   * The HTMLFile transport creates a `forever iframe` based transport
   * for Internet Explorer. Regular forever iframe implementations will 
   * continuously trigger the browsers buzy indicators. If the forever iframe
   * is created inside a `htmlfile` these indicators will not be trigged.
   *
   * @constructor
   * @extends {io.Transport.XHR}
   * @api public
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HTMLFile</span> <span class="hljs-params">(socket)</span> {</span>
    io.Transport.XHR.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };

  <span class="hljs-comment">/**
   * Inherits from XHR transport.
   */</span>

  io.util.inherit(HTMLFile, io.Transport.XHR);

  <span class="hljs-comment">/**
   * Transport name
   *
   * @api public
   */</span>

  HTMLFile.prototype.name = <span class="hljs-string">'htmlfile'</span>;

  <span class="hljs-comment">/**
   * Creates a new Ac...eX `htmlfile` with a forever loading iframe
   * that can be used to listen to messages. Inside the generated
   * `htmlfile` a reference will be made to the HTMLFile transport.
   *
   * @api private
   */</span>

  HTMLFile.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.doc = <span class="hljs-keyword">new</span> window[([<span class="hljs-string">'Active'</span>].concat(<span class="hljs-string">'Object'</span>).join(<span class="hljs-string">'X'</span>))](<span class="hljs-string">'htmlfile'</span>);
    <span class="hljs-keyword">this</span>.doc.open();
    <span class="hljs-keyword">this</span>.doc.write(<span class="hljs-string">'&lt;html&gt;&lt;/html&gt;'</span>);
    <span class="hljs-keyword">this</span>.doc.close();
    <span class="hljs-keyword">this</span>.doc.parentWindow.s = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> iframeC = <span class="hljs-keyword">this</span>.doc.createElement(<span class="hljs-string">'div'</span>);
    iframeC.className = <span class="hljs-string">'socketio'</span>;

    <span class="hljs-keyword">this</span>.doc.body.appendChild(iframeC);
    <span class="hljs-keyword">this</span>.iframe = <span class="hljs-keyword">this</span>.doc.createElement(<span class="hljs-string">'iframe'</span>);

    iframeC.appendChild(<span class="hljs-keyword">this</span>.iframe);

    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
      , query = io.util.query(<span class="hljs-keyword">this</span>.socket.options.query, <span class="hljs-string">'t='</span>+ +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>);

    <span class="hljs-keyword">this</span>.iframe.src = <span class="hljs-keyword">this</span>.prepareUrl() + query;

    io.util.on(window, <span class="hljs-string">'unload'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      self.destroy();
    });
  };

  <span class="hljs-comment">/**
   * The Socket.IO server will write script tags inside the forever
   * iframe, this function will be used as callback for the incoming
   * information.
   *
   * @param {String} data The message
   * @param {document} doc Reference to the context
   * @api private
   */</span>

  HTMLFile.prototype._ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data, doc)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>unescape all forward slashes. see GH-1251</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    data = data.replace(<span class="hljs-regexp">/\\\//g</span>, <span class="hljs-string">'/'</span>);
    <span class="hljs-keyword">this</span>.onData(data);
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">var</span> script = doc.getElementsByTagName(<span class="hljs-string">'script'</span>)[<span class="hljs-number">0</span>];
      script.parentNode.removeChild(script);
    } <span class="hljs-keyword">catch</span> (e) { }
  };

  <span class="hljs-comment">/**
   * Destroy the established connection, iframe and `htmlfile`.
   * And calls the `CollectGarbage` function of Internet Explorer
   * to release the memory.
   *
   * @api private
   */</span>

  HTMLFile.prototype.destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iframe){
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">this</span>.iframe.src = <span class="hljs-string">'about:blank'</span>;
      } <span class="hljs-keyword">catch</span>(e){}

      <span class="hljs-keyword">this</span>.doc = <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">this</span>.iframe.parentNode.removeChild(<span class="hljs-keyword">this</span>.iframe);
      <span class="hljs-keyword">this</span>.iframe = <span class="hljs-literal">null</span>;

      CollectGarbage();
    }
  };

  <span class="hljs-comment">/**
   * Disconnects the established connection.
   *
   * @returns {Transport} Chaining.
   * @api public
   */</span>

  HTMLFile.prototype.close = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.destroy();
    <span class="hljs-keyword">return</span> io.Transport.XHR.prototype.close.call(<span class="hljs-keyword">this</span>);
  };

  <span class="hljs-comment">/**
   * Checks if the browser supports this transport. The browser
   * must have an `Ac...eXObject` implementation.
   *
   * @return {Boolean}
   * @api public
   */</span>

  HTMLFile.check = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(socket)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> window != <span class="hljs-string">"undefined"</span> &amp;&amp; ([<span class="hljs-string">'Active'</span>].concat(<span class="hljs-string">'Object'</span>).join(<span class="hljs-string">'X'</span>)) <span class="hljs-keyword">in</span> window){
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> window[([<span class="hljs-string">'Active'</span>].concat(<span class="hljs-string">'Object'</span>).join(<span class="hljs-string">'X'</span>))](<span class="hljs-string">'htmlfile'</span>);
        <span class="hljs-keyword">return</span> a &amp;&amp; io.Transport.XHR.check(socket);
      } <span class="hljs-keyword">catch</span>(e){}
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  <span class="hljs-comment">/**
   * Check if cross domain requests are supported.
   *
   * @returns {Boolean}
   * @api public
   */</span>

  HTMLFile.xdomainCheck = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>we can probably do handling for sub-domains, we should
test that it’s cross domain but a subdomain here</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  <span class="hljs-comment">/**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */</span>

  io.transports.push(<span class="hljs-string">'htmlfile'</span>);

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io.Transport : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
);

<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io, global)</span> {</span>

  <span class="hljs-comment">/**
   * Expose constructor.
   */</span>

  exports[<span class="hljs-string">'xhr-polling'</span>] = XHRPolling;

  <span class="hljs-comment">/**
   * The XHR-polling transport uses long polling XHR requests to create a
   * "persistent" connection with the server.
   *
   * @constructor
   * @api public
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">XHRPolling</span> <span class="hljs-params">()</span> {</span>
    io.Transport.XHR.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };

  <span class="hljs-comment">/**
   * Inherits from XHR transport.
   */</span>

  io.util.inherit(XHRPolling, io.Transport.XHR);

  <span class="hljs-comment">/**
   * Merge the properties from XHR transport
   */</span>

  io.util.merge(XHRPolling, io.Transport.XHR);

  <span class="hljs-comment">/**
   * Transport name
   *
   * @api public
   */</span>

  XHRPolling.prototype.name = <span class="hljs-string">'xhr-polling'</span>;

  <span class="hljs-comment">/**
   * Indicates whether heartbeats is enabled for this transport
   *
   * @api private
   */</span>

  XHRPolling.prototype.heartbeats = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  <span class="hljs-comment">/** 
   * Establish a connection, for iPhone and Android this will be done once the page
   * is loaded.
   *
   * @returns {Transport} Chaining.
   * @api public
   */</span>

  XHRPolling.prototype.open = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    io.Transport.XHR.prototype.open.call(self);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  };

  <span class="hljs-comment">/**
   * Starts a XHR request to wait for incoming messages.
   *
   * @api private
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">empty</span> <span class="hljs-params">()</span> {</span>};

  XHRPolling.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isOpen) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stateChange</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.readyState == <span class="hljs-number">4</span>) {
        <span class="hljs-keyword">this</span>.onreadystatechange = empty;

        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status == <span class="hljs-number">200</span>) {
          self.onData(<span class="hljs-keyword">this</span>.responseText);
          self.get();
        } <span class="hljs-keyword">else</span> {
          self.onClose();
        }
      }
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onload</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">this</span>.onload = empty;
      <span class="hljs-keyword">this</span>.onerror = empty;
      self.retryCounter = <span class="hljs-number">1</span>;
      self.onData(<span class="hljs-keyword">this</span>.responseText);
      self.get();
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onerror</span> <span class="hljs-params">()</span> {</span>
      self.retryCounter ++;
      <span class="hljs-keyword">if</span>(!self.retryCounter || self.retryCounter &gt; <span class="hljs-number">3</span>) {
        self.onClose();  
      } <span class="hljs-keyword">else</span> {
        self.get();
      }
    };

    <span class="hljs-keyword">this</span>.xhr = <span class="hljs-keyword">this</span>.request();

    <span class="hljs-keyword">if</span> (global.XDomainRequest &amp;&amp; <span class="hljs-keyword">this</span>.xhr <span class="hljs-keyword">instanceof</span> XDomainRequest) {
      <span class="hljs-keyword">this</span>.xhr.onload = onload;
      <span class="hljs-keyword">this</span>.xhr.onerror = onerror;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.xhr.onreadystatechange = stateChange;
    }

    <span class="hljs-keyword">this</span>.xhr.send(<span class="hljs-literal">null</span>);
  };

  <span class="hljs-comment">/**
   * Handle the unclean close behavior.
   *
   * @api private
   */</span>

  XHRPolling.prototype.onClose = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    io.Transport.XHR.prototype.onClose.call(<span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.xhr) {
      <span class="hljs-keyword">this</span>.xhr.onreadystatechange = <span class="hljs-keyword">this</span>.xhr.onload = <span class="hljs-keyword">this</span>.xhr.onerror = empty;
      <span class="hljs-keyword">try</span> {
        <span class="hljs-keyword">this</span>.xhr.abort();
      } <span class="hljs-keyword">catch</span>(e){}
      <span class="hljs-keyword">this</span>.xhr = <span class="hljs-literal">null</span>;
    }
  };

  <span class="hljs-comment">/**
   * Webkit based browsers show a infinit spinner when you start a XHR request
   * before the browsers onload event is called so we need to defer opening of
   * the transport until the onload event is called. Wrapping the cb in our
   * defer method solve this.
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */</span>

  XHRPolling.prototype.ready = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(socket, fn)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    io.util.defer(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      fn.call(self);
    });
  };

  <span class="hljs-comment">/**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */</span>

  io.transports.push(<span class="hljs-string">'xhr-polling'</span>);

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io.Transport : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
  , <span class="hljs-keyword">this</span>
);

<span class="hljs-comment">/**
 * socket.io
 * Copyright(c) 2011 LearnBoost &lt;dev@learnboost.com&gt;
 * MIT Licensed
 */</span>

(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(exports, io, global)</span> {</span>
  <span class="hljs-comment">/**
   * There is a way to hide the loading indicator in Firefox. If you create and
   * remove a iframe it will stop showing the current loading indicator.
   * Unfortunately we can't feature detect that and UA sniffing is evil.
   *
   * @api private
   */</span>

  <span class="hljs-keyword">var</span> indicator = global.document &amp;&amp; <span class="hljs-string">"MozAppearance"</span> <span class="hljs-keyword">in</span>
    global.document.documentElement.style;

  <span class="hljs-comment">/**
   * Expose constructor.
   */</span>

  exports[<span class="hljs-string">'jsonp-polling'</span>] = JSONPPolling;

  <span class="hljs-comment">/**
   * The JSONP transport creates an persistent connection by dynamically
   * inserting a script tag in the page. This script tag will receive the
   * information of the Socket.IO server. When new information is received
   * it creates a new script tag for the new data stream.
   *
   * @constructor
   * @extends {io.Transport.xhr-polling}
   * @api public
   */</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">JSONPPolling</span> <span class="hljs-params">(socket)</span> {</span>
    io.Transport[<span class="hljs-string">'xhr-polling'</span>].apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

    <span class="hljs-keyword">this</span>.index = io.j.length;

    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;

    io.j.push(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg)</span> {</span>
      self._(msg);
    });
  };

  <span class="hljs-comment">/**
   * Inherits from XHR polling transport.
   */</span>

  io.util.inherit(JSONPPolling, io.Transport[<span class="hljs-string">'xhr-polling'</span>]);

  <span class="hljs-comment">/**
   * Transport name
   *
   * @api public
   */</span>

  JSONPPolling.prototype.name = <span class="hljs-string">'jsonp-polling'</span>;

  <span class="hljs-comment">/**
   * Posts a encoded message to the Socket.IO server using an iframe.
   * The iframe is used because script tags can create POST based requests.
   * The iframe is positioned outside of the view so the user does not
   * notice it's existence.
   *
   * @param {String} data A encoded message.
   * @api private
   */</span>

  JSONPPolling.prototype.post = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(data)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
      , query = io.util.query(
             <span class="hljs-keyword">this</span>.socket.options.query
          , <span class="hljs-string">'t='</span>+ (+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>) + <span class="hljs-string">'&amp;i='</span> + <span class="hljs-keyword">this</span>.index
        );

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.form) {
      <span class="hljs-keyword">var</span> form = document.createElement(<span class="hljs-string">'form'</span>)
        , area = document.createElement(<span class="hljs-string">'textarea'</span>)
        , id = <span class="hljs-keyword">this</span>.iframeId = <span class="hljs-string">'socketio_iframe_'</span> + <span class="hljs-keyword">this</span>.index
        , iframe;

      form.className = <span class="hljs-string">'socketio'</span>;
      form.style.position = <span class="hljs-string">'absolute'</span>;
      form.style.top = <span class="hljs-string">'0px'</span>;
      form.style.left = <span class="hljs-string">'0px'</span>;
      form.style.display = <span class="hljs-string">'none'</span>;
      form.target = id;
      form.method = <span class="hljs-string">'POST'</span>;
      form.setAttribute(<span class="hljs-string">'accept-charset'</span>, <span class="hljs-string">'utf-8'</span>);
      area.name = <span class="hljs-string">'d'</span>;
      form.appendChild(area);
      document.body.appendChild(form);

      <span class="hljs-keyword">this</span>.form = form;
      <span class="hljs-keyword">this</span>.area = area;
    }

    <span class="hljs-keyword">this</span>.form.action = <span class="hljs-keyword">this</span>.prepareUrl() + query;

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">complete</span> <span class="hljs-params">()</span> {</span>
      initIframe();
      self.socket.setBuffer(<span class="hljs-literal">false</span>);
    };

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initIframe</span> <span class="hljs-params">()</span> {</span>
      <span class="hljs-keyword">if</span> (self.iframe) {
        self.form.removeChild(self.iframe);
      }

      <span class="hljs-keyword">try</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>ie6 dynamic iframes with target=”” support (thanks Chris Lambacher)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        iframe = document.createElement(<span class="hljs-string">'&lt;iframe name="'</span>+ self.iframeId +<span class="hljs-string">'"&gt;'</span>);
      } <span class="hljs-keyword">catch</span> (e) {
        iframe = document.createElement(<span class="hljs-string">'iframe'</span>);
        iframe.name = self.iframeId;
      }

      iframe.id = self.iframeId;

      self.form.appendChild(iframe);
      self.iframe = iframe;
    };

    initIframe();</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>we temporarily stringify until we figure out how to prevent
browsers from turning <code>\n</code> into <code>\r\n</code> in form inputs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">this</span>.area.value = io.JSON.stringify(data);

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">this</span>.form.submit();
    } <span class="hljs-keyword">catch</span>(e) {}

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iframe.attachEvent) {
      iframe.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">if</span> (self.iframe.readyState == <span class="hljs-string">'complete'</span>) {
          complete();
        }
      };
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">this</span>.iframe.onload = complete;
    }

    <span class="hljs-keyword">this</span>.socket.setBuffer(<span class="hljs-literal">true</span>);
  };

  <span class="hljs-comment">/**
   * Creates a new JSONP poll that can be used to listen
   * for messages from the Socket.IO server.
   *
   * @api private
   */</span>

  JSONPPolling.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>
      , script = document.createElement(<span class="hljs-string">'script'</span>)
      , query = io.util.query(
             <span class="hljs-keyword">this</span>.socket.options.query
          , <span class="hljs-string">'t='</span>+ (+<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>) + <span class="hljs-string">'&amp;i='</span> + <span class="hljs-keyword">this</span>.index
        );

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.script) {
      <span class="hljs-keyword">this</span>.script.parentNode.removeChild(<span class="hljs-keyword">this</span>.script);
      <span class="hljs-keyword">this</span>.script = <span class="hljs-literal">null</span>;
    }

    script.async = <span class="hljs-literal">true</span>;
    script.src = <span class="hljs-keyword">this</span>.prepareUrl() + query;
    script.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      self.onClose();
    };

    <span class="hljs-keyword">var</span> insertAt = document.getElementsByTagName(<span class="hljs-string">'script'</span>)[<span class="hljs-number">0</span>];
    insertAt.parentNode.insertBefore(script, insertAt);
    <span class="hljs-keyword">this</span>.script = script;

    <span class="hljs-keyword">if</span> (indicator) {
      setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
        <span class="hljs-keyword">var</span> iframe = document.createElement(<span class="hljs-string">'iframe'</span>);
        document.body.appendChild(iframe);
        document.body.removeChild(iframe);
      }, <span class="hljs-number">100</span>);
    }
  };

  <span class="hljs-comment">/**
   * Callback function for the incoming message stream from the Socket.IO server.
   *
   * @param {String} data The message
   * @api private
   */</span>

  JSONPPolling.prototype._ = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg)</span> {</span>
    <span class="hljs-keyword">this</span>.onData(msg);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isOpen) {
      <span class="hljs-keyword">this</span>.get();
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  <span class="hljs-comment">/**
   * The indicator hack only works after onload
   *
   * @param {Socket} socket The socket instance that needs a transport
   * @param {Function} fn The callback
   * @api private
   */</span>

  JSONPPolling.prototype.ready = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(socket, fn)</span> {</span>
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">if</span> (!indicator) <span class="hljs-keyword">return</span> fn.call(<span class="hljs-keyword">this</span>);

    io.util.load(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
      fn.call(self);
    });
  };

  <span class="hljs-comment">/**
   * Checks if browser supports this transport.
   *
   * @return {Boolean}
   * @api public
   */</span>

  JSONPPolling.check = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">'document'</span> <span class="hljs-keyword">in</span> global;
  };

  <span class="hljs-comment">/**
   * Check if cross domain requests are supported
   *
   * @returns {Boolean}
   * @api public
   */</span>

  JSONPPolling.xdomainCheck = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  };

  <span class="hljs-comment">/**
   * Add the transport to your public io.transports array.
   *
   * @api private
   */</span>

  io.transports.push(<span class="hljs-string">'jsonp-polling'</span>);

})(
    <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io.Transport : module.exports
  , <span class="hljs-string">'undefined'</span> != <span class="hljs-keyword">typeof</span> io ? io : module.parent.exports
  , <span class="hljs-keyword">this</span>
);

<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">"function"</span> &amp;&amp; define.amd) {
  define([], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> {</span> <span class="hljs-keyword">return</span> io; });
}
})();</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
